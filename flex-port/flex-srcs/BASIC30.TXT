 NAM DISK BASIC 3.0
*REV 9 MC6809
 OPT PAG
 PAG
*******************************************************
*
*           SWTPC DISK BASIC FOR
*           FLEX OPERATING SYSTEM 
*           VERSION 3.0
*
*
*           MODS FOR 6809 
*
*******************************************************
*
* PAGE ZERO GLOBAL STORAGE
*
FIFLAG EQU $0010 INPUT FROM FILE FLAG
FOFLAG EQU $0011 OUTPUT TO FILE FLAG
FILON EQU $0012 FILE ACTIVE FLAG
CURFCB EQU $0013 CURRENT FILE BLOCK ADDRESS
FNUMBR EQU $0015 CURRENT FILE NUMBER
ECHO EQU $0016 INPUT ECHO AT TERMINAL
CHAINN EQU $0017 CHAIN START LIN NUMBER
ERRSAV EQU $0020 ERROR NUMBER SAVE
INDEX3 EQU $0024
INDEX4 EQU $0026
SAVSP EQU $0028 STACK TEMP SAVE
ENDPTR EQU $002A END OF SOURCE
WORKBA EQU $002C SOURCE POINTER FOR INS/DEL LINE
BEGPTR EQU $002E START OF SOURCE
PAKLIN EQU $0030 TEMP STORAGE FOR LINE NUMBER
HILINE EQU $0032 HIGHEST LINE# IN BASIC SOURCE
BASPNT EQU $0034 POINTER TO NEXT CHAR OF SOURCE
BASLIN EQU $0036 LINE POINTER
PUSHTX EQU $0038 X REG SAV FOR PUSHX
XSTKPT EQU $003A X STACK POINTER
DATPNT EQU $003C POINTER TO DATA FOR READ
STRLEN EQU $003E SIZE OF STRING
PRCNT EQU $0040 CURRENT OUTPUT COLUMN
COSXSV EQU $0041 TEMP STARAGE FOR COS. SERIES
STRTRM EQU $0043 STRING TERMINATOR FLAG=0 USE QUOTE
*                NOT ZERO USE NULL FOR TERMINATOR 
SGNFLG EQU $0043 SIGN FLAG FOR FUNCTIONS
TOPMEM EQU $0044 HIGHEST AVAILIBLE RAM
FREPTR EQU $0046 FREE MEM FOR VARIBLE ALLOCATION
KEYWRD EQU $0048 POINTER TO KEYWORD
TSIGN EQU $004A TEMP SIGN HOLDER
EXPNT EQU $004B EXPONENT FOR INPUT
SIGDIG EQU $004C INPUT DIGIT COUNTER
DECFLG EQU $004D DECIMAL POINT FLAG
TOGGLE EQU $004E NIBBLE COUNTER FOR INPUT
LOGSGN EQU $004E EXPONENT SIGN FOR FOL 
TEMPIF EQU $004F IF COMPARE FLAG
TNUM EQU $0050
ANUM EQU $0051
BNUM EQU $0052
LRNINE EQU $0053
DIGFLG EQU $0054 NUMBER OF DIGITS FOR PRINT
ONLOOP EQU $0055 ON GO-TO-SUB SKIP COUNT
NORSGN EQU $0056
XLONG EQU $0057
MPYXXX EQU $0059
BASNUM EQU $005B LINE NUMBER SAVE
PNTRAE EQU $005D POINTER TO TOP ELEMENT ON ARITH STACK
FORPTR EQU $005F POINTER TO FOR STACK
FORNOW EQU $0061 
VARPTR EQU $0063 POINTER TO VARIBLE
SUBPTR EQU $0065 POINTER TO SUBROUTINE STACK
USRPTR EQU $0067 POINTER TO USER SUBROUTINE
RNDOMN EQU $0069 RANDOM NUMBER
FORTMP EQU $006F ACCUMULATOR FOR FOR-NEXT INCREMENT
SUBSTK EQU $0075 GOSUB STACK
LOAFLG EQU $0085
STRFLG EQU $0086 STRING VARIBLE FLAG
TRFLAG EQU $0087 TRACE FLAG
SXSAVE EQU $0088
IOXSAV EQU $008A TEMP STORAGE
OUTPTR EQU $008C POINTER TO OUT CHAR
INPPTR EQU $008E POINTER TO IN CHAR
PORADR EQU $0090 CURRENT PORT ADDRESS
LINLEN EQU $0092 MAX LINE LENGTH ON OUTPUT
COLWID EQU $0093 MAX COLUMN WIDTH ON OUTPUT
STRPTR EQU $0094 POINTER TO STRING WORK SPACE
CURPRT EQU $0096 CURRENT PORT NUMBER
TANACC EQU $0097 TEMP ACCUM. 
TRNACC EQU $009D TEMP ACCUM.
LOGACC EQU $00A3 LOG ACCUMULATOR
PRTDIG EQU $00A9
XADDER EQU $00AA ACCUM (16BIT) FOR LINE POINTERS
BUFNXT EQU $00AC LINE BUFFER POINTER
ENDBUF EQU $00AE LAST IN BUFFER
BUFFER EQU $00B0 LINE INPUT BUFFER
LEND EQU $00F8 SHORT BUFFER FOR TERM
FBEND EQU $00FF END OF BUFFER
 PAG
****************************************
* PROGRAM START
 ORG $0100
*
BASIC JSR BACOLD COLD START ENTRY
RESTRT JMP BAWARM WARM START ENTRY

*PORT JUMP TABLE
JMPPT0 JMP OACIA
 JMP INACIA
 JMP INITA
*PORT 1
 JMP PUTCHR
 JMP GETCHR
 JMP USER01
*PORT 2
 JMP OACIA
 JMP INACIA
 JMP INITA
*PORT 3
 JMP OACIA
 JMP INACIA
 JMP INITA
*PORT 4
 JMP OUTPIA
 JMP INPIA
 JMP INITP
*PORT 5
 JMP OUTPIA
 JMP INPIA
 JMP INITP
*PORT 6
 JMP OUTPIA
 JMP INPIA
 JMP INITP
*PORT 7
 JMP OUTPIA
 JMP INPIA
 JMP INITP

CTLPRT FCB $01 CONTROL PORT NUMBER
 FCB $00
BRKCHR FCB $03
 FCB $00
 PAG
****************************************
*FUNCTION LOOKUP TABLE

FUNCT FCC "RND"
 FCB $00
 FDB RND

 FCC "TAB("
 FCB $00
 FDB TAB

 FCC "INT("
 FCB $00
 FDB INTGER

 FCC "CHR$("
 FCB $00
 FDB CHR

 FCC "ABS("
 FCB $00
 FDB ABS

 FCC "SGN("
 FCB $00
 FDB SIGN

 FCC "SQR("
 FCB $00
 FDB SQROOT

 FCC "LOG("
 FCB $00
 FDB LOG

 FCC "EXP("
 FCB $00
 FDB EXP

 FCC "SIN("
 FCB $00
 FDB SINE

 FCC "COS("
 FCB $00
 FDB COSINE

 FCC "ATAN("
 FCB $00
 FDB ARCTAN

 FCC "PEEK("
 FCB $00
 FDB PEEK

 FCC "POS"
 FCB $00
 FDB POSITN

 FCC "TAN("
 FCB $00
 FDB TANGNT

 FCC "VAL("
 FCB $00
 FDB VALUE

 FCC "ASC("
 FCB $00
 FDB ASCII

 FCC "LEN("
 FCB $00
 FDB LENGTH

 FCC "LEFT$("
 FCB $00
 FDB LEFT

 FCC "RIGHT$("
 FCB $00
 FDB RIGHT

 FCC "MID$("
 FCB $00
 FDB MIDSTR

 FCC "STR$("
 FCB $00
 FDB STRING

 FCC "FN"
 FCB $00
 FDB FNX

 FCC "EOF("
 FCB $00
 FDB EOF

 FCC "USER("
FEND FCB $00
 FDB USER

 FCB $00 END OF TABLE MARKER
 PAG
****************************************
* BASIC COMMANDS
*
 FCB $99 NON ZERO USED BY LIST LINE
 FCB $99 SAME HERE

CMDTBL FCC "LIST" COMMAND NAME
 FCB $00 TERMINATOR
 FDB LIST EXECUTION ADDRESS 

 FCC "NEW"
 FCB $00
 FDB NEW

 FCC "EXIT"
 FCB $00
 FDB MONTOR

 FCC "GOSUB"
 FCB $00
 FDB GOSUB

 FCC "GOTO"
 FCB $00
 FDB GOTO

 FCC "ON"
 FCB $00
 FDB ON

 FCC "THEN"
 FCB $00
 FDB THEN

 FCC "PRINT"
 FCB $00
 FDB PRINT

 FCC "LET"
 FCB $00
 FDB LET

 FCC "INPUT"
 FCB $00
 FDB INPUT

 FCC "IF"
 FCB $00
 FDB IF

 FCC "READ"
 FCB $00
 FDB READ

 FCC "DATA"
 FCB $00
DATTOK FDB DATA

 FCC "RESTORE"
 FCB $00
 FDB RESTOR

 FCC "END"
 FCB $00
 FDB END

 FCC "POKE("
 FCB $00
 FDB POKE

 FCC "RETURN"
 FCB $00
 FDB RETURN

 FCC "DIM"
 FCB $00
 FDB DIM

 FCC "DEF"
 FCB $00
 FDB DEF

 FCC "FOR"
 FCB $00
 FDB FOR

 FCC "NEXT"
 FCB $00
 FDB NEXT

 FCC "REM"
 FCB $00
 FDB REMARK

 FCC "TRACEON"
 FCB $00
 FDB TRON

 FCC "TRACEOFF"
 FCB $00
 FDB TROFF

 FCC "LINE="
 FCB $00
 FDB LINEEQ

 FCC "DIGITS="
 FCB $00
 FDB DIGITS

STPMSG FCC "STOP"
 FCB $00
 FDB STOP

 FCB $20 IMPLIED LET
 FCB $00 
LETPTR FDB LET

 FCC "RUN"
 FCB $00
 FDB RUN

 FCC "CONT"
 FCB $00
 FDB CONT

 FCC "TLOAD"
 FCB $00
 FDB TLOAD

 FCC "TSAVE"
 FCB $00
 FDB TSAVE

 FCC "TAPPEND"
 FCB $00
 FDB TAPPND

 FCC "LOAD"
 FCB $00
 FDB LOAD

 FCC "SAVE"
 FCB $00
 FDB SAVE

 FCC "APPEND"
 FCB $00
 FDB APPEND

 FCC "PORT="
 FCB $00
 FDB PORT

 FCC "DOS"
 FCB $00
 FDB FLEX

 FCC "CHAIN"
 FCB $00
 FDB CHAIN

 FCC "OPEN"
 FCB $00
 FDB OPEN

 FCC "CLOSE"
 FCB $00
 FDB CLOSE

 FCC "WRITE"
 FCB $00
 FDB WRITE

 FCC "STRING="
 FCB $00
 FDB STREQU

 FCC "KILL"
 FCB $00
 FDB KILL

 FCC "RENAME"
 FCB $00
 FDB RENAME

 FCC "SCRATCH"
 FCB $00
 FDB SCRAT

 FCC "CAT"
 FCB $00
 FDB CATLOG

TOTBL FCC "TO"
 FCB $00
TOTOKN FDB INP10

 FCC "STEP"
LSTCMD FCB $00
 FDB INP10
 PAG
****************************************
*BASIC MESSAGES
READY FCC "READY"
 FCB $00

DELETD FCC " DELETED"
 FCB $00

HOMEUP FCB $10
 FCB $16
 FCB $00

RENTR FCC "RE-ENTER"
 FCB $00

ERRMSG FCC "ERROR #"
 FCB $00

INLINE FCC " IN LINE "
 FCB $00
 PAG
****************************************
*CHARACTER IO ROUTINES
* INIT ACIA
INITA LDX PORADR
 LDA #$13
 STA $00,X
 LDA #$11
 STA $00,X
 RTS

*INIT PIA
INITP LDX PORADR
 CLR $01,X
 CLR $03,X
 CLR $00,X
 CLR $02,X
 COM $00,X
 LDA #$3E
 STA $01,X
 LDA #$2E
 STA $03,X
 RTS

*PRINT 2 HEX CHARS
P2HEX LDA $00,X
 BSR OUTHL
 LDA $00,X
 LEAX 1,X
 BRA OUTHR

*PRINT 4 HEX AND SPACE
OUT4HS BSR P2HEX
 BSR P2HEX
 LDA #$20
 BRA OUTCHR

*PRINT LEFT HEX CHAR
OUTHL LSRA
 LSRA
 LSRA
 LSRA

*OUT RIGHT HEX CHAR
OUTHR ANDA #$0F 
 ADDA #$30
 CMPA #$39
 BLS OUTCHR
 ADDA #$07

*PRINT CHARACTER
OUTCHR TST FOFLAG
 BNE OUTFIL
 PSHB
 PSHA 
 STX IOXSAV
 LDX OUTPTR
 JSR $00,X
 LDX IOXSAV
 PULA 
 PULB 
 RTS 

*SEND CHAR TO FILE
OUTFIL STX IOXSAV
 PSHA 
 LDX CURFCB
 JSR FILEIO
 LDX IOXSAV
 PULA 
 RTS 

*INPUT FROM FILE
INPFIL STX IOXSAV
INPF1 LDX CURFCB
 JSR FILEIO
 BNE INPF3
 CMPA #$0D
 BEQ INPF2
 CMPA #$1F
 BLS INPF1
INPF2 LDX IOXSAV
 RTS 
INPF3 LDA #$1A
 LDX IOXSAV
 RTS 

*INPUT ONE CHARACTER
INCHR TST FIFLAG
 BNE INPFIL
 STX IOXSAV
 PSHB 
 LDX INPPTR
 JSR $00,X
 LDX IOXSAV
 PSHA 
 BRA BRKTS1

*CHECK CONTROL TERMINAL FOR BREAK CHAR.
BRKTST PSHB
 PSHA
 JSR STATCK CHECK STATUS
 BEQ BRKTS2
 JSR GETCHR INPUT CHAR
 ANDA #$7F
BRKTS1 CMPA BRKCHR IS IT BREAK CHAR
 BNE BRKTS2
 JMP END
BRKTS2 PULA 
 PULB 
 RTS 

*INPUT FROM ACIA
INACIA LDX PORADR
 LDA $00,X
 ASRA 
 BCC INACIA
 LDA $01,X
 ANDA #$7F
 CMPA #$7F
 BEQ INACIA

*OUTPUT TO ACIA
OACIA LDX PORADR
 LDB $00,X
 ASRB 
 ASRB 
 BCC OACIA
 STA $01,X
 RTS 

*INPUT FROM PIA
INPIA LDX PORADR
 LDB $03,X
 BPL INPIA
 LDA $02,X
 STA $02,X
 RTS 

*OUTPUT TO PIA
OUTPIA LDX PORADR
 CMPA #$7F
 BEQ OUTP2
 STA $00,X
 LDB #$36
 STB $01,X
 LDB #$3E
 STB $01,X
OUTP1 LDB $01,X
 BPL OUTP1
 LDA $00,X
OUTP2 RTS 
 PAG
****************************************
*INPUT BUFFER MANAGEMENT
*
FILDEL LDX #DELETD PRINT DELETED MESSAGE
 JSR PSTRNG
 BRA FILBUF REFILL BUFFER

PROMPT LDA #'? PROMPT FOR DATA
 JSR OUTCHR
 JSR OUTSP

FILBUF LDX #BUFFER POINT TO BUFFER
FILL1 JSR INCHR GET CHAR
FILL2 TSTA SKIP NULLS
 BEQ FILL1
 CMPA #$0A LINE FEED?
 BEQ FILL1 SKIP IT
 CMPA #$15 
 BEQ FILL1
 CMPA TTYDEL DELETE BUFFER?
 BEQ FILDEL
 CMPA #$0D RETURN?
 BEQ MKEOL
 CMPA #$1A 
 BEQ MKEOL
 CMPA TTYBS BACK SPACE?
 BNE FILL4
 LDA TTYBE GET BACK SPACE ECHO
 CMPA #$08 IS IT BS?
 BEQ ECHOBS
FILL3 JSR OUTCHR SEND ECHO CHAR
 CPX #BUFFER WE AT START OF BUFFER?
 BEQ FILL1
 LEAX -1,X BACK UP ONE
 BRA FILL1
ECHOBS LDA #$20 ECHO SPACE
 JSR OUTCHR
 LDA #$08 BACK SPACE TO BLANK UNDER CURSOR
 BRA FILL3
FILL4 TST LOAFLG
 BNE FILL5
 CPX #LEND TEST FOR END OF BUFFER
FILL5 BNE FILL6
 CLR $00,X MARK END
 LDB #$21
 JMP ERROR REPORT ERROR
FILL6 CMPA #$1F NON PRINTING CHAR?
 BLS FILL1 THEN SKIP IT
 CPX #FBEND END OF BUFFER?
 BEQ FILL1
 STA $00,X SAVE CHAR IN BUFFER
 LEAX 1,X INC POINTER
 BRA FILL1 LOOP FOR MORE

*INPUT SOURCE LINE
INPLIN LDA #'# PROMPT FOR LINE
 JSR OUTCHR
 BRA FILBUF

*MARK END OF LINE
MKEOL CLR $00,X
 STX ENDBUF SAVE END POINTER
 LDA LOAFLG WE DOING FILE?
 BNE MKEOL2
 JSR PCRLF DO CRLF IF NOT FILE
MKEOL2 RTS 

*PRINT STRING THEN CRLF
PSTRNG BSR PDATA
 BRA PCRLF

*PRINT NULL TERMINATED STRING
PDAT1 JSR OUTCHR
 LEAX 1,X
PDATA LDA $00,X GET CHAR
 ANDA #$7F MASK PARITY BIT
 BNE PDAT1 LOOP TO PRINT IF NOT NULL
 RTS 

*PRINT CARRAGE RETURN LINE FEED
PCRLF LDA PORADR+1 CHECK PORT
 CMPA #$04 IF SYSTEM CONSOLE
 BNE PCRLF1
 JMP FPCRLF THEN LET DOS DO CRLF

*CRLF FOR NON SYS CONSOLE
PCRLF1 BSR PUSHX
 LDX #CRLF
 BSR PDATA
 BSR PULLX
 RTS 

CRLF FCB $0D,$0A,$00

 PAG
****************************************
*STACK MANAGEMENT

*PUSH X ON PSEUDO STACK
PUSHX STX PUSHTX
 LDX XSTKPT POINT TO  STACK 
 LEAX -2,X MAKE SPACE
 STX XSTKPT SAVE POINTER
 PSHA 
 LDA PUSHTX GET X MSB
 STA $00,X STORE
 LDA PUSHTX+1 GET X LSB
 STA $01,X STORE
 PULA 
 LDX PUSHTX RECOVER X
 RTS 

*PULL X FROM PSEUDO STACK
PULLX LDX XSTKPT POINT TO STACK
 LDX 0,X LOAD X FROM TOS
*THIS WILL FAIL IF STACK NOT ALIGNED ON PAGE ADDRESS
PULLX1 INC XSTKPT+1 POINT TO NEXT STACK ENTRY
 INC XSTKPT+1
 RTS 

*MOVE FROM ARITH STACK TO X 
MOVARX BSR PUSHX SAVE X
 JSR PULLAE GET POINTER TO TOP OF ARITH STACK
 TFR X,Y MOVE TO Y
 LDX XSTKPT 
 LDX $00,X RECOVER X FROM STACK
 BRA STORX2

*MOVE ARITH STACK TO VARIBLE
MOVARV BSR PUSHX
 JSR PULLAE GET POINTER TO TOS
 TFR X,Y
 LEAX -7,X REMOVE FROM STACK
 STX PNTRAE STORE POINTER
 LDX $00,X GET VARIBLE ADDRESS FROM AR STACK
STORX2 LDB #$05 SET BYTE COUNT
STORX3 LDA 0,Y+
 STA $00,X+ MOVE BYTE
 DECB 
 BNE STORX3 LOOP TILL DONE
 LDA 1,Y
 STA $00,X
 BSR PULLX
 RTS

*MOVE FROM X TO ARITH STACK
MOVXAR BSR PUSHX
 TFR X,Y
 BRA IND0

*MOVE FROM VARIBLE TO ARITH STACK
MOVVAR BSR PUSHX
 JSR PULLAE
 LDY $00,X GET SOURCE ADDRESS
IND0 LDB #$05 BYTE COUNT
 LDX PNTRAE GET POINTER TO TOP OF ARITH STACK
IND01 LDA 0,Y+ MOVE ONE
 STA $00,X+
 DECB 
 BNE IND01 LOOP
 LDA 0,Y+ GET LAST BYTE
 STA $01,X 
 CLR $00,X
 JSR PUSHAE PUSH ON AR STACK
 JSR PULLX
 RTS
 PAG
****************************************
*LIST ONE LINE TO OUTPUT
LSTLIN JSR OUT4HS PRINT LINE NUMBER
 JSR PUSHX SAVE POINTER
 LDX $00,X GET POINTER TO COMMAND TABLE
 LEAX -1,X BACK OVER NULL IN TABLE
LSTLN1 LEAX -1,X
 INCB 
 LDA $00,X GET CHAR
 BNE LSTLN1 BACKUP POINTER UNTILL CHAR=NULL
 LEAX 3,X SKIP OVER NULL AND ADDRESS
 DECB 
 DECB 
 JSR PDATA PRINT KEYWORD
 BSR OUTSP AND SPACE
 CLR PRCNT
 JSR PULLX RECOVER LINE POINTER
 LEAX 3,X
 TST FOFLAG WE DOING FILES?
 BNE LSTLN2
 JMP PSTRNG THEN LIST AND CRLF
LSTLN2 JSR PDATA LIST TO FILE
 LDA #$0D RETURN ONLY FOR FILE
 JMP OUTCHR

*PRINT A SPACE
OUTSP PSHA
 LDA #$20
 JSR OUTCHA
 PULA 
 RTS 
 PAG
****************************************
*FIND A VARIBLE SETS VARPTR IF VALID
FINVAR JSR SKPSPC SKIP SPACES
 JSR ISLTR NEXT CHAR LETTER?
 BCS FINV11 GET OUT IF NOT
 TAB 
 LDA $01,X GET NEXT
 JSR ISLTR IS LETTER TOO?
 BCS FINV12
 JSR FUNSCH MUST BE FUNCTION NAME
 LDX $00,X
 JSR $00,X DO-IT
 JSR PUSHAE SAVE RESULT ON ARITH STACK
 LDX BASPNT
 LEAS 4,S CLEANUP
 CLC
 RTS BYE

FINV11 SEV THIS IS NOT GOOD 
 RTS 

FINV12 JSR ISNUMB IS IT LETTER-NUMBER COMBO
 BCC FINV3 BRANCH IF SO
 CMPA #$24 STRING VARIBLE?
 BEQ FINV3
 LEAX -1,X BACK UP
 LDA #$20 SINGLE CHAR NAMES STORE AS LETTER-SPACE
FINV3 LEAX 1,X SKIP TRAILING 
 LEAX 1,X
 PSHB 
 LDB $00,X GET NEXT CHAR
 CMPB #'( WE GOT SUBSCRIPT?
 BNE FINV31
 LEAX 1,X SKIP OVER "("
 ORAA #$80 MARK AS ARRAY
FINV31 PULB 
 JSR PUSHX
 LDX ENDPTRPOINT TO END OF BASIC SOURCE
FINV4 CPX FREPTR END OF ALLOCATED VARIBLES?
 SEC 
 BEQ FINV5 THEN SAVE END POINTER AS ADDRESS
 CMPB $00,X VARIBLE NAME MATCH?
 BNE FINV6
 CMPA $01,X BOTH PARTS?
 BNE FINV6
 CLC 
FINV5 STX VARPTR SAVE POINTER TO VARIBLE
 JSR PULLX
 CLV 
 RTS WE GONE 
*SKIP TO NEXT VARIBLE 
FINV6 TST $01,X
 BMI FINV7 IS IT ARRAY?
 PSHA 
 LDA $01,X
 CMPA #$24 IS IT STRING?
 PULA 
 BNE FINV61
*SKIP OVER STRING
 JSR STRNGM SKIP OVER SIZE OF STRING
FINV61 JSR INX8 ADD HOUSEKEEP SPACE
 BRA FINV4 KEEP SEARCHING
*SKIP OVER ARRAY
FINV7 LDX $04,X POINT TO NEXT VARIBLE
 BRA FINV4 KEEP LOOKING
 PAG
****************************************
*TEST FOR VALID VARIBLE NAME
TSTVAR JSR BRKTST OPERATOR WANT SOMETHING?
 CLR STRFLG CLEAR STRING FLAG
 JSR FINVAR LOCATE VARIBLE
 BVC TSTV1
 RTS EXIT IF NO GOOD

TSTV1 PSHA SAVE VAR NAME
 PSHB 
 BCS TSTV41 NEW VARIBLE?
 STX BASPNT
 LDX VARPTR
 TSTA 
 BMI TSTV3 WAS IT SUBSCRIPTED
TSTV11 LEAX 1,X
 LEAX 1,X
TSTV2 STX VARPTR
 LDX PNTRAE
 LDA VARPTR
 STA $00,X SET VAR ADDRESS ON ARITH STACK
 LDA VARPTR+1
 STA $01,X
 JSR PUSHAE
 PULB 
 PULA 
 CMPA #'$ STRING?
 BNE TSTV21
 STA STRFLG SET STRING FLAG
TSTV21 LDX BASPNT
 CLC 
 RTS

*TRY TO FIND ARRAY 
TSTV3 JSR GETPAR GET SUBSCRIPT
 BCC TSTV35 BRANCH IF ONLY ONE
TSTV34 JSR FIX CONVERT TO FIXED POINT
 BRA TSTV36
TSTV35 CLRB FORCE UNUSED INDEX TO 0
TSTV36 PSHB SAVE IT
 JSR FIX CONVERT SECOND SUBSCRIPT
 TBA 
 LDB $01,X
 CMPB #$A4 STRING+ARRAY?
 BNE TSTV4
 STB STRFLG SET STRING FLAG
TSTV4 PULB 
 JSR RESERV SAVE SPACE
 BRA TSTV2
*ALLOCATE NEW VARIBLE
TSTV41 STX BASPNT
 LDX VARPTR
 STB $00,X SAVE NAME
 STA $01,X
 TSTA 
 BPL TSTV6 NOT ARRAY?
 LDB #$0A SIZE OF NUMERIC
 STB $02,X PUT IN TABLE
 STB $03,X
 JSR GETPAR
 BCS TSTV5
 CLRB 
 STB $03,X
TSTV5 LDA $02,X
 JSR ALLOCV ALLOCATE VARIBLE
 TST $03,X
 BEQ TSTV35
 BRA TSTV34
TSTV6 LDA $01,X
 CMPA #'$ IS IT STRING
 BNE TSTV7
 JSR STRNGM GET SPACE FOR IT
 STA STRFLG SET STRING FLAG
TSTV7 JSR INX8
 STX FREPTR SAVE NEW TOP OF POOL
 LDX VARPTR
 BRA TSTV11

*TEST CHARACTER FOR LETTER
ISLTR PSHA 
 ANDA #$7F REMOVE PARITY BIT
 CMPA #'A GT EQ A
 BMI ITSNOT
 CMPA #'Z LT EQ Z
 BLE ITIS
 BRA ITSNOT

*TEST CHARACTER FOR NUMBER
ISNUMB PSHA 
 CMPA #'0
 BMI ITSNOT GREATER THAN OR EQ 0
 CMPA #'9
 BLE ITIS AND LESS THAN OR EQ 9
ITSNOT SEC 
 PULA 
 RTS 
ITIS CLC THEN ITS A NUMBER
 PULA 
 RTS 
 PAG
****************************************
*PUSH ON ARITH STACK
PUSHAE LDX PNTRAE
 BSR INX7
PSHAE1 STX PNTRAE
 RTS 

*PULL FROM ARITH STACK
PULLAE LDX PNTRAE
 BSR DEX7
 BRA PSHAE1

*USEFULL
DEX8 LEAX -1,X
DEX7 LEAX -1,X
DEX6 LEAX -1,X
DEX5 LEAX -5,X
 RTS 

*INC INDEX BY SIZE OF STRING
STRNGM PSHB 
 LDB STRLEN
 SUBB #$06
 STX XADDER
 ADDB XADDER+1
 STB XADDER+1
 LDB #$00
 ADCB XADDER
 STB XADDER
 PULB 
 LDX XADDER
 BRA MEMTST

*UTILITY
INX8 LEAX 1,X
INX7 LEAX 1,X
INX6 LEAX 1,X
INX5 LEAX 5,X

*CHECK FOR OUT OF MEMORY
MEMTST CPX TOPMEM
 BCS MEMOK
 JMP NOMEM
MEMOK RTS 

*CONVERT FLOAT TO FIXED POINT
*EIGHT BIT FIXED POINT
FIX BSR DFIX DO CONVERSION
 TSTA MSB MUST BE ZERO
 BNE FIXERR
 RTS 

*SIXTEEN BIT FIXED POINT CONVERSION
DFIX JSR PUSHX SAVE POINTER
 BSR PULLAE POP ARG FROM ARITH STACK
 LDA $06,X CHECK EXPONENT
 CMPA #$05 LESS THA OR EQ 5
 BLE DFIX1
FIXERR LDB #$01
 JMP ERROR REPORT ERROR
DFIX1 CLRA  CLEAR RESULT
 CLRB 
 TST $00,X
 BMI FIXERR CANT CONVERT NEGATIVE NUMBER
DFIX2 TST $06,X 
 BLE DFIX3
 ASLB MULT BY TWO
 ROLA 
 STB BNUM SAVE PARTIAL PRODUCT
 STA ANUM
 ASLB  NOW TIMES 4
 ROLA 
 BCS FIXERR
 ASLB NOW TIMES 8
 ROLA 
 BCS FIXERR
 ADDB BNUM ADD TIMES TWO
 ADCA ANUM GIVES US TIMES 10
 BCS FIXERR OVERFLOW?
 ADDB $00,X ADD DIGIT
 ADCA #$00
 BCS FIXERR OOPS!
 JSR ALLEFT SHIFT LEFT
 DEC $06,X CORRECT EXPONENT
 BNE DFIX2 LOOP TILL ZERO
DFIX3 JSR PULLX 
 RTS 
 PAG
****************************************
*ISOLATE FACTOR ON AR STACK 
FACT JSR SKPSPC
 JSR TSTVAR VALID VARIBLE?
 BCS FACT1 
 TST STRFLG
 BNE PARER3
 JSR MOVVAR MOVE VARIBLE TO ARITH STACK
 RTS 
FACT1 JSR NUMCON TRY FOR NUMERIC CONSTANT
 BCS FACT2 NOT CONSTANT MUST BE EXPRESSION
 RTS 
FACT2 CMPA #'( MUST START WITH LEFT PAREN.
 BNE PARER2 WE GOT ERROR
 LEAX 1,X SKIP LEFT PAREN THEN PARSE

*PARSE EXPRESSION IN PAREN.
PAREXP JSR EVAL EVALUATE EXPRESSION
 JSR SKPSPC
 CMPA #') SHOULD END IN RIGHT PAREN.
 BNE PARERR
 LEAX 1,X SKIP TERMINATOR
 RTS 

PARERR LDB #$13
PARER1 STX BASPNT
 JMP ERROR REPORT ERROR

PARER2 LDB #$06
 BRA PARER1

PARER3 LDB #$24
 BRA PARER1
 PAG
****************************************
*CHECK FOR EXPONENT
EXOP BSR FACT ISOLATE FACTOR ON STACK
EXOP1 JSR SKPSPC
 CMPA #'^ GOT EXPONENT?
 BEQ EXPONT
 RTS BYE

*DO EXPONENT
EXPONT LEAX 1,X SKIP SYMBOL
 STX BASPNT
 LDX PNTRAE
 JSR DEX7
 LDB $00,X
 PSHB 
 BEQ EXPON1
 JSR LOG1 GET LOG OF NUMBER
 JSR PUSHAE SAVE FOR A WHILE
EXPON1 LDX BASPNT
 JSR SKPSPC
 CMPA #'- NEGATIVE POWER?
 BNE EXPON2
 LEAX 1,X
 BSR FACT GET EXPONENT
 JSR NEGATE MAKE POSITIVE
 BRA EXPON3
EXPON2 BSR FACT GET EXPONENT
EXPON3 STX BASPNT
 LDX PNTRAE
 JSR DEX7
 LDA $00,X
 PULB 
 TSTB 
 BNE EXPON4
 TSTA 
 BEQ EXPON4
 JSR PULLAE
 BRA EXPON7
EXPON4 PSHA 
 TSTA 
 BPL EXPON5
 JSR NEGATE
EXPON5 JSR MULT MULT LOG BY DESIRED POWER
 JSR EXP01 THEN DO ANTILOG
 PULA 
 TSTA 
 BPL EXPON6
 JSR SWAP
 JSR ACCEQ1 SET ACCUM EQ 1.00
 JSR PUSHAE
 JSR DIVIDE
 BRA EXPON7
EXPON6 JSR PUSHAE
EXPON7 LDX BASPNT
 BRA EXOP1
 PAG
****************************************
*TERM
TERM BSR EXOP DO EXPONENT IF ANY
TERM01 JSR SKPSPC
 CMPA #'* MULTIPLY
 BNE TERM02
 LEAX 1,X SKIP MULT SYMBOL
 JSR SKPSPC SKIP ANY SPACES
 JSR EXOP DO EXPONENT IF ANY
 JSR MULT THEN MULTIPLY
 BRA TERM01
TERM02 CMPA #'/ DIVIDE
 BNE TERM03
 LEAX 1,X
 JSR EXOP DO EXPONENT IF ANY
 JSR DIVIDE THEN DIVIDE
 BRA TERM01 TRY FOR NEXT TERM
TERM03 RTS
 
*EVALUATE EXPRESSION
*RESULT LEFT ON ARITH STACK
EVAL JSR SKPSPC
 CLR STRFLG
 CMPA #'- UNARY MINUS?
 BNE EVAL1
 LEAX 1,X
 BSR TERM PUSH TERM TO STACK
 JSR NEGATE MAKE TOS NEGATIVE
 BRA EVAL3
EVAL1 CMPA #'+ UNARY PLUS?
 BNE EVAL2
 LEAX 1,X SKIP IT
EVAL2 BSR TERM PUSH TERM TO STACK
EVAL3 JSR SKPSPC SKIP SYMBOL
 CMPA #'+ BINARY PLUS
 BNE EVAL4
 LEAX 1,X
 BSR TERM ISOLATE TERM
 JSR ADD ADD VALUES ON STACK
 BRA EVAL3
EVAL4 CMPA #'- BINARY MINUS
 BNE EVAL5
 LEAX 1,X SKIP SYMBOL
 BSR TERM PUSH TERM TO STACK
 JSR SUB SUBTRACT
 BRA EVAL3 LOOP
EVAL5 TSTA 
 RTS 

*EVALUATE STRING
EVALST JSR PUSHX
 BSR STREVL
 TST STRFLG
 BNE SEV01
 JSR PULLX
 BRA EVAL
SEV01 JSR FSTRNG FIND START OF WORK STRING
 JSR PULLX
 BSR STREVL
SEV021 LDA SXSAVE+1
 CMPA #$7F
 BCS CONCAT
 JMP MIDST2

*STRING CONCATINATION
CONCAT JSR SKPSPC
 CMPA #'+
 BNE CONCA2
 LEAX 1,X SKIP OVER PLUS
 BSR STREVL EVALUATE ARGUMENT
 TST STRFLG GOT A STRING?
 BEQ CONCA3
 JSR PUSHX
 JSR FSTRNG FIND START OF WORK STRING
 LEAX -1,X BACKUP ONE
CONCA1 LDB $01,X MOVE UPPER STRING DOWN
 STB $00,X
 LEAX 1,X
 TSTB 
 BNE CONCA1
 STX SXSAVE
 JSR PULLX
 BRA SEV021
CONCA2 TSTA 
 RTS
 
CONCA3 LDB #$24
 STX BASPNT
 JMP ERROR REPORT ERROR

STREVL JSR SKPSPC SKIP OVER SPACES
 CMPA #'"
 BNE STRPAR
 STA STRFLG SET STRING FLAG
 LEAX 1,X
 TFR X,Y
 LDX SXSAVE
SEVL1 LDA 0,Y+
 CMPA #'"
 BEQ SEVL2
 STA $00,X+
 TSTA 
 BNE SEVL1

 LDB #$04
 JMP ERROR REPORT ERROR

SEVL2 CLR $00,X+
 STX SXSAVE
 TFR Y,X
 RTS 

STRPAR JSR SKPSPC SKIP OVER SPACES
 JSR TSTVAR
 BCC STRP01
 RTS 
STRP01 TST STRFLG
 BEQ STRP04
 STX BASPNT
 JSR PULLAE
 LDX $00,X
 TFR X,Y
 LDX SXSAVE
 LDB STRLEN
STRP02 LDA 0,Y+
 STA $00,X
 TSTA
 BEQ STRP03
 LEAX 1,X
 DECB
 BNE STRP02
 CLR $00,X
STRP03 LEAX 1,X
 STX SXSAVE
 LDX BASPNT
 RTS
STRP04 JSR PULLAE
 RTS 
STRP05 JSR PUSHX
 JSR INX7
 BRA NEGA2

*NEGATE OPERAND AT TOS
NEGATE JSR PUSHX
 LDX PNTRAE
 LEAX -1,X
 LEAX -1,X
 BRA NEGA3
NEGA1 JSR PUSHX
NEGA2 JSR INX5
NEGA3 PSHA 
 PSHB 
 LDB #$06
NEGA4 LDA #$99
 SUBA $00,X
 STA $00,X
 LEAX -1,X
 DECB 
 BNE NEGA4
 JSR INX6
 SEC 
 LDB #$06
NEGA5 LDA #$00
 ADCA $00,X
 DAA 
 STA $00,X
 LEAX -1,X
 DECB 
 BNE NEGA5
 JSR PULLX
 PULB 
 PULA 
 RTS 

*SHIFT LEFT
ALLEFT PSHA 
 BSR LLEFT
 LDA $00,X
 ANDA #$0F
 STA $00,X
 PULA 
 RTS 

LLEFT PSHA 
 PSHB 
 STX XLONG
 LDB #$04
LLEF1 LDX XLONG
 JSR INX5
 ASL $00,X
 LDA #$05
LLEF2 LEAX -1,X
 ROL $00,X
 DECA 
 BNE LLEF2
 DECB 
 BNE LLEF1
 PULB 
 PULA 
 RTS 

*SHIFT RIGHT
LRIGHT PSHA 
 PSHB 
 STX XLONG
 LDA $00,X
 ANDA #$F0
 STA LRNINE
 LDB #$04
LRGT1 LDX XLONG
 LSR $00,X
 LDA #$05
LRGT2 LEAX 1,X
 ROR $00,X
 DECA 
 BNE LRGT2
 DECB 
 BNE LRGT1
 LDX XLONG
 LDA $00,X
 ADDA LRNINE
 STA $00,X
 PULB 
 PULA 
 RTS 

*NORMALIZE VALUE AT TOP OF STACK
NORMAL JSR PUSHX
 JSR PULLAE GET POINTER
 CLR NORSGN CLEAR SIGN
 JSR TSTZER CANT NORMALIZE ZERO
 BCC NORM2
 LDA $00,X
 BPL NORM1
 STA NORSGN SET SIGN
 JSR NEGA1 MAKE POSITIVE
NORM0 LDA #$0F MASK OFF SIGN
 ANDA $00,X
 STA $00,X
NORM1 LDA $00,X MSB NOT ZERO
 BNE NORM3 THEN WERE FINISHED
 BSR ALLEFT SHIFT LEFT
 DEC $06,X CORRECT EXP.
 BRA NORM1 AND LOOP
NORM2 CLR $06,X
NORM3 CLR $05,X REMOVE LSB
 LDA $06,X CHECK EXPONENT
 CMPA #$65 OVERFLOW?
 BLT NORM5
 PSHB 
 LDB #$05 THEN SET TO 999999999E99
 LDA #$99
NORM4 STA $00,X
 LEAX 1,X
 DECB 
 BNE NORM4
 LDA #$64 SET EXP TO 99
 STA $01,X
 JSR DEX5
 PULB 
 BRA NORM0
NORM5 CMPA #$9D UNDERFLOW (-99)
 BGT NORM6
 JSR CLRACC THEN SET TO ZERO
NORM6 TST NORSGN TEST SAVED SIGN
 BEQ NORM7 POSITIVE THEN EXIT
 JSR NEGA1 MAKE OPERAND NEGATIVE
NORM7 JSR PUSHAE
 JSR PULLX
 RTS 
 PAG
****************************************
*FLOATING POINT SUBTRACT
SUB JSR NEGATE MAKE OPERAND NEGATIVE AND ADD

*FLOATING POINT ADD
ADD JSR PUSHX
 JSR PULLAE
 JSR TSTZER TEST FOR ZERO
 BCC ADD3 DONT ADD ZERO
 JSR LRIGHT MAKE ROOM FOR CARRY
 INC $06,X CORRECT EXP
 JSR PULLAE POINT TO SECOND OPER
 JSR TSTZER IS IT ZERO
 BCC ADD1 THEN SWAP OPERANDS
ADD0 JSR LRIGHT MAKE ROOM FOR CARRY
 INC $06,X CORRECT EXP.
 LDA $06,X GET EXP
 CMPA $0D,X COMPARE TO SECOND OPERAND
 BEQ ADD2 SAME THEN ADD
 BLT ADD0 LARGER THEN SHIFT
 BSR SWAP SMALLER THEN SWAP
 BRA ADD0 AND TRY TO MATCH
ADD1 BSR SWAP
ADD2 BSR ADDER ADD OPERANDS
 JSR PUSHAE
 JSR NORMAL NORMALIZE RESULT
ADD3 JSR PULLX
 RTS 

*SWAP OPERANDS ON ARITH STACK
SWAP LDX PNTRAE GET POINTER TO TOP OF STACK (ARITH)
 PSHB 
 PSHA 
 LDB #$07 BYTES TO SWAP
SWAP1 LDA $00,X GET ONE
 PSHA 
 LDA $07,X GET OTHER
 STA $00,X STORE OTHER
 PULA 
 STA $07,X STORE ONE
 LEAX 1,X 
 DECB LOOP TILL DONE
 BNE SWAP1
 LDX PNTRAE
 PULA 
 PULB 
 RTS 

*DECIMAL ADD
ADDER PSHA 
 PSHB 
 LDX PNTRAE POINT TO STACK
 LDB #$06 SET COUNT
 CLC 
ADDER1 LDA $05,X ADD TWO NIBBLES
 ADCA $0C,X TO TOS+1
 DAA  ADJUST DECIMAL
 STA $05,X SAVE IT
 LEAX -1,X POINT TO NEXT BYTE
 DECB 
 BNE ADDER1 LOOP
 LDX PNTRAE
 PULB 
 PULA 
 RTS 

*FLOATING POINT DIVIDE
DIVIDE JSR PUSHX
 JSR CLRACC
 JSR PULLAE
 JSR TSTZER
 BCS DIV1
 LDB #$08
 JMP ERROR REPORT ERROR
DIV1 NEG $06,X
 BSR MDSIGN
 JSR LRIGHT
 JSR STRP05
 LDA #$0B
DIV2 CLRB 
DIV3 INCB 
 BSR ADDER
 TST $00,X
 BPL DIV3
 DECB 
 JSR STRP05
 BSR ADDER
 JSR STRP05
 JSR INX7
 JSR INX7
 JSR LLEFT
 ADDB $05,X
 STB $05,X
 LDX PNTRAE
 JSR LLEFT
 DECA 
 BNE DIV2
 JSR PUSHAE
 JSR SWAP
 INC TNUM
 BRA MDEXIT

MDSIGN JSR LRIGHT
 CLRA 
 TST $00,X
 BPL MDSGN1
 JSR NEGA1
 LDA #$80
MDSGN1 JSR PULLAE
 TST $00,X
 BPL MDSGN2
 JSR NEGA1
 ADDA #$80
MDSGN2 STA TSIGN
 LDA $06,X
 ADDA $0D,X
 BVC MDSGN3
 LDA #$78
 BCC MDSGN3
 NEGA 
MDSGN3 STA TNUM
 RTS
 
*FLOATING POINT MULTIPLY
MULT JSR PUSHX
 JSR PULLAE
 BSR MDSIGN
 STX MPYXXX
 JSR PUSHAE
 JSR SWAP
 JSR CLRACC
 LDA #$09
MULT1 LDX MPYXXX
 LDB $00,X
 JSR ALLEFT
MULT2 TSTB 
 BEQ MULT3
 JSR ADDER
 DECB 
 BRA MULT2
MULT3 LDX PNTRAE
 JSR INX7
 JSR LRIGHT
 DECA 
 BNE MULT1
MDEXIT JSR PULLAE
 JSR SWAP
 LDA TNUM
 STA $06,X
 JSR PUSHAE
 JSR NORMAL
 TST TSIGN
 BPL MDXIT1
 JSR NEGATE
MDXIT1 JSR PULLX
 RTS 

*LOCATE LINE NUMBER IN SOURCE
FINDNO LDA HILINE GET CURRENT LINE NUMBER
 LDB HILINE+1
 SUBB PAKLIN+1 SUB DESIRED LINE
 SBCA PAKLIN
 BCS FINNO4 NOT IN SOURCE?
*SEARCH THROUGH SOURCE
FINNO1 LDX BEGPTR POINT TO SRC
 CPX ENDPTR AT END?
 BEQ FINNO4
FINNO2 LDA PAKLINGET DESIRED LINE
 LDB PAKLIN+1
 SUBB $01,X CMP TO CURRENT LINE
 SBCA $00,X
 BCS FINNO5 GREATER?
 BNE FINNO3 NOT SAME
 TSTB 
 BEQ FINNO6 GOT MATCH
FINNO3 STX XADDER SAVE LINE POINTER
 CLRA 
 LDB $04,X ADD LENGTH OF LINE 
 ADDB XADDER+1
 ADCA XADDER
 STB XADDER+1
 STA XADDER
 LDX XADDER
 CPX ENDPTR AT END OF SOURCE?
 BNE FINNO2
FINNO4 LDX ENDPTR RETURN END OF SOURCE
FINNO5 SEC NOT HERE
FINNO6 STX WORKBA SET POINTER TO LINE OR END
 RTS
 
*SKIP SPACES
SKPSPC LDA $00,X
 CMPA #$20
 BNE SKIP2
SKIP1 LEAX 1,X
 BRA SKPSPC
SKIP2 TSTA 
 RTS 

*PARSE LINE NUMBER
FINDLN JSR NUMCON GET NUMBER
 BCC FLN2
FLN1 LDB #$07
 JMP ERROR REPORT ERROR
FLN2 STX BUFNXT
 JSR PULLAE POP POINTER OFF STACK
 LDB $06,X GET EXPONENT
 BLS FLN1 CANT BE MINUS
 CMPB #$04 OR GT THAN 4
 BGT FLN1
 LDA #$05 MAX DIGIT COUNT
 SBA 
FLN3 TSTA 
 BEQ FLN4
 JSR LRIGHT SHIFT RIGHT
 DECA 
 BRA FLN3
FLN4 LDA $01,X GET TWO DIGITS
 STA PAKLIN STORE HI BYTE
 LDA $02,X TWO MORE 
 STA PAKLIN+1 LOW BYTE
 LDX BUFNXT
 CLC 
 RTS

*FIND PHYSICAL END OF LINE 
FINEOL LDX BASPNT POINT TO SOURCE
FEOL1 LDA $00,X GET CHAR
 LEAX 1,X INC POINTER
 TSTA CHAR = NULL?
 BNE FEOL1 NO THEN LOOP
 STX BASLIN
 RTS 

*FIND LOGICAL END OF LINE
NXTLIN LDX BASPNT
NXLN1 LDA $00,X GET CHAR
 LEAX 1,X INC POINTER
 TSTA NULL? 
 BEQ NXLN2
 CMPA #': LINE SEPARATOR?
 BNE NXLN1
NXLN2 STX BASLIN
 RTS 
 PAG
****************************************
*FUNCTION TABLE SEARCH
FUNSCH STX BUFNXT
 LDX #FUNCT-1
 BRA SRCH

*TOTABLE SEARCH
TOSCH STX BUFNXT
 LDX #TOTBL-1
 BRA SRCH

*COMMAND TABLE SEARCH
CMDSCH BSR SKPSPC
 STX BUFNXT SAVE POINTER
 STX BASPNT
 LDX #CMDTBL-1 POINT TO TABLE

SRCH LDY BUFNXT POINT TO BUFFER
SRCH1 LEAX 1,X POINT TO NEXT IN TABLE
SRCH2 LDA 0,Y+ GET BUFFER CHAR
 CMPA #$20 IS IT SPACE?
 BEQ SRCH2 THEN SKIP IT
 CMPA #$5F LOWER CASE?
 BLE SRCH3
 ANDA #$DF CONVERT TO UPPER
SRCH3 LDB $00,X GET TABLE CHAR
 BEQ SRCH5 NULL ENDS ENTRY
 CMPA 0,X MATCH?
 BEQ SRCH1 CHECK NEXT
*CHARACTER NOT MATCH SKIP TO NEXT ENTRY
SRCH4 LEAX 1,X POINT TO NEXT IN TABLE
 CPX #LSTCMD END OF TABLE
 BEQ SETLET THEN ASSUME LET STATEMENT
 CPX #FEND FUNCTION SEARCH END?
 BEQ SRCH6
 LDB $00,X CHECK NEXT ENTRY
 BNE SRCH4 ZERO ENDS ENTRY 
 LEAX 2,X SKIP OVER ADDRESS
 BRA SRCH CONTINUE
*ENTRY FOUND
SRCH5 LEAX 1,X SKIP NAME TERMINATOR
 LEAY -1,Y
 STY BUFNXT SET POINTERS
 STY BASPNT
 RTS 
*NO MATCH SO ASSUME LET
SETLET LDX #LETPTR
 RTS 
SRCH6 JMP INP10
 PAG
******************************************
*CLEAR SOURCE
CLRSRC LDX #PRGEND POINT TO END OF INTERPRETER
 STX BEGPTR SET POINTERS
 STX ENDPTR
 STX FREPTR
 CLRA 
 STA HILINE SET HILINE NUM TO ZERO
 STA HILINE+1
 STA PRCNT COLUMN ZERO
 STA STRFLG CLEAR STRING FLAG
 STA TRFLAG TRACE OFF
 STA DIGFLG PRINT FORMAT FLOATING
 LDX #USER01 SET SAFE POINTER FOR USER
 STX USRPTR
 RTS 
 PAG
*********************************************
* BASIC COLD START ENTRY
*
BACOLD CLR PORADR+1 CLEAR PORT ADDRESS
 LDA CTLPRT SET CONTROL PORT
 STA CURPRT MAKE CURRENT
 CLR FILON FILES OFF
 LDA #32 SET DEFAULT STRING LENGTH
 STA STRLEN

*ERASE BASIC SOURCE
NEW BSR CLRSRC CLEAR SOURCE
 LDA #$40
 STA LINLEN SET DEFAULT LINE LENGTH
 LDA #$30
 STA COLWID
 LDX #RESTRT SETUP ESCAPE RETURN
 STX ESCRET
 JMP RUN

******************************************
* BASIC WARM START ENTRY
*
BAWARM LDA CTLPRT
 STA CURPRT SET DEFAULT PORT
 LDX #RESTRT
 STX ESCRET SET ESCAPE RETURN ADDRESS
 CLR FILON TURN OFF FILE I/O
BWARM1 LDS TOPMEM SET UP STACK
 LDX #ARSTAK SETUP X STACK
 STX XSTKPT
 CLRA 
 STA LOAFLG FILES OFF
 STA FIFLAG NO FILE INPUT
 STA FOFLAG NO FILE OUTPUT
 STA DRVTYP USE SYSYEM DRIVE
 JSR SPORT1 SET TO CONTROL PORT
 TST FILON
 BEQ BWARM2
 CLR PRCNT COLUMN = ZERO
 JMP RUN
BWARM2 LDA #$13 PUNCH OFF
 JSR OUTCHR
 LDA #$14 READER OFF
 JSR OUTCHR
 JSR PCRLF
 LDX #READY PROMPT
 JSR PSTRNG
BMAIN CLR PRCNT
 JSR INPLIN GET LINE
 LDX #BUFFER
 JSR SKPSPC SKIP OVER SPACES
 JSR ISNUMB GOT LINE NUMBER?
 BCS BNONUM
 JSR SORTIN PUT IT IN SOURCE
 BRA BMAIN AND LOOP
BNONUM TSTA NULL LINE? 
 BEQ BMAIN THEN SKIP IT
 JSR CMDSCH SEARCH FOR KEYWORD
 LDX $00,X POINT TO EXECUTION ADDRESS
 JMP $00,X AND DO IT!
 PAG
**********************************
*REPORT ERROR
*
ERROR LDS TOPMEM SET STACK
 CLI 
 STB ERRSAV SAVE ERROR NUMBER
 JSR SPORT1 SET CONTROL PORT
 JSR PCRLF NEW LINE
 LDX BASNUM POINT TO LINE NUMBER
 LDX $00,X GET NUMBER
 STX PAKLIN SAVE IT
 LDA BASPNT GET LINE POINTER
 BNE ERROR1 IF ZERO DIRECT MODE
 CLR PAKLIN SO LINE NUMBER EQ ZERO
 CLR PAKLIN+1
ERROR1 LDX #ERRMSG PRINT ERROR MESSAGE
 JSR PDATA 
 LDX #ERRSAV PRINT ERROR CODE
 JSR P2HEX
 LDX #INLINE LINE NUMBER MESSAGE
 JSR PDATA
 LDX #PAKLIN THEN LINE NUMBER
 JSR OUT4HS
 JSR PCRLF
 JSR FMSCLS CLOSE ANY OPEN FILES
 CLR FILON
 JMP BWARM1 GOTO WARM START
 PAG
************************************************
*START EXECUTION OF BASIC PROGRAM
*
RUN LDX BEGPTR BEGINNING OF SOURCE
 STX DATPNT RESET DATA POINTER
 STX BASLIN RESET LINE POINTER
 LDX #FCBLST CLEAR FILE BLOCK LIST
RUN1 CLR $00,X
 LEAX 1,X
 CPX #ASTACK END OF LIST?
 BNE RUN1
 JSR FMSCLS CLOSE OPEN FILES
 LDX #SUBSTK RESET SUBROUTINE STACK
 STX SUBPTR
 LDX #FORSTK RESET FOR/NEXT STACK
 STX FORPTR
 LDX ENDPTR POINT TO END OF SOURCE
 STX FREPTR SET FREE MEMORY POINTER
 LDA #$B3 TEST RAM
 LEAX -1,X
RUN2 LEAX 1,X
 CPX MEMEND END OF AVAILABLE RAM?
 BEQ RUN3
 STA $00,X WRITE LOCATION
 CMPA $00,X DID IT CHANGE?
 BNE RUN3 
 CLR $00,X THEN CLEAR IT
 BRA RUN2 AND LOOP
RUN3 LEAX -1,X BACK UP ONE
 STX TOPMEM SAVE POINTER TO TOP OF MEMORY
 STX STRPTR SET POINTER TO STRING WORK SPACE
 CLR STRPTR+1 ALLOCATE 256 BYTES AT TOP OF MEM
 CLRA 
 STA FIFLAG CLEAR FILE I/O FLAGS
 STA FOFLAG
 TST FILON
 BEQ RUN4
 CLR FILON
 LDX CHAINN CHECK CHAIN LINE NUMBER
 BNE RUN5
RUN4 JMP CONT1
RUN5 STX PAKLIN SET LINE NUMBER
 JMP GOTO3 GOTO IT
 PAG
*************************************************
*LIST PROGRAM OR RANGE OF LINES
*LIST [LINENO][-LINENO] 
*
LIST JSR SETPRT SET UP PORT
 LDX #HOMEUP CLEAR SCREEN
 JSR PSTRNG
 LDX BASPNT POINT TO COMMAND LINE
 JSR SKPSPC SKIP OVER SPACES
 BEQ LIST2 NULL=END OF LINE
 JSR FINDLN GET LINE NUMBER
 STX BASPNT
 JSR FINNO1 LOCATE LINE
 STX INDEX3 SAVE POINTER
 LDX BASPNT
 JSR SKPSPC SKIP OVER SPACES
 BEQ LIST1 ONLY ONE ARGUMENT?
 LEAX 1,X SKIP SEPERATOR
 JSR FINDLN GET ENDING LINE NUMBER
LIST1 CLRA 
 LDB #$01
 ADDB PAKLIN+1 ADD 1 TO TARGET LINE 
 DAA 
 STB PAKLIN+1
 ADCA PAKLIN
 DAA 
 STA PAKLIN
 JSR FINNO1 LOCATE TARGET
 LDX INDEX3 GET START 
 BRA LIST3
LIST2 LDX ENDPTR
 STX WORKBA
 LDX BEGPTR
LIST3 CPX WORKBA AT TARGET?
 BEQ LIST4
 CPX ENDPTR AT END OF SOURCE?
 BEQ LIST4
 JSR LSTLIN LIST ONE LINE
 LEAX 1,X
 BRA LIST3
LIST4 JMP DATA 
 PAG
****************************************
*SET STRING LENGTH
STREQU LDX BASPNT
 JSR EVAL EVALUATE EXPRESSION
 JSR FIX CONVERT TO FIXED POINT
 ANDB #$7F MAX LENGTH =128
 STB STRLEN SAVE LENGTH
 JMP DATA

****************************************
*JUMP TO DOS
MONTOR NOP 
 JSR DEL1 DELAY
 JMP FLEX
 PAG
****************************************
*LOAD AND EXEC DISK PROGRAM
*CHAIN[ LINENUM]
CHAIN INC FILON
 LDX #SYSFCB POINT TO FILE BLOCK
 STX CURFCB 
 JSR FIXSTR GET FILE NAME
 LDX CURFCB
 CLR $0C,X 
 LDA #$03
 JSR SETEXT FORCE EXTENTION TO BAS
 LDX BASPNT
 JSR SKPSPC SKIP OVER SPACES
 BEQ CHAN2
 CMPA #': END OF LINE?
 BEQ CHAN2
 CMPA #',
 BNE CHAN1
 LEAX 1,X
CHAN1 JSR FINDLN GET STARTING LINE NUMBER
 LDA PAKLIN
 STA CHAINN SET CHAIN LINE
 LDA PAKLIN+1
 STA CHAINN+1
 BRA CHAN3
CHAN2 CLRA CLEAR LINE NUMBER
 STA CHAINN
 STA CHAINN+1
CHAN3 JSR CLRSRC CLEAR SOURCE
 JMP APND1 LOAD FILE
 PAG
****************************************
*SAVE PROGRAM TO DISK
*SAVE[ FILENAME]
SAVE BSR NAMFIL GET FILE NAME
 LDX CURFCB 
 LDA #$02
 STA $00,X OPEN FOR READ
 JSR FILEIO CALL FILE MANAGER
 INC FOFLAG MARK FILE OPEN
 LDX BEGPTR POINT TO SRC
SAVE1 CPX ENDPTR AT END?
 BEQ SAVE2
 JSR LSTLIN LIST (SAVE) ONE LINE
 LEAX 1,X
 BRA SAVE1 LOOP
SAVE2 LDX CURFCB
 LDA #$04
 STA $00,X
 JSR FILEIO CLOSE FILE
 JMP BWARM1

****************************************
*LOAD PROGRAM FROM DISK
*LOAD[ FILENAME]
LOAD JSR CLRSRC

****************************************
*APPEND PROGRAM FROM DISK
*APPEND[ FILENAME]
APPEND BSR NAMFIL GET FILE NAME
APND1 LDX CURFCB POINT TO FCB
 LDA #$0F
 STA FNUMBR SET FILE NUMBER FOR ERROR RPT
 LDA #$01
 STA LOAFLG
 STA $00,X
 JSR FILEIO OPEN FILE FOR READ
 INC FIFLAG
APND2 JSR INCHR GET CHAR
 CMPA #$1A END OF FILE?
 BEQ SAVE2
 JSR ISNUMB 
 BCS APND3 NOT NUMBER?
 LDX #BUFFER
 JSR FILL2 FILL LINE BUFFER
 LDX #BUFFER
 JSR SORTIN ADD TO MEMORY
 BRA APND2 LOOP
APND3 CMPA #$0D SKIP TO END OF LINE
 BEQ APND2
 JSR INCHR
 CMPA #$1A END OF FILE?
 BEQ SAVE2
 BRA APND3
 PAG
****************************************
*GET FILE NAME
NAMFIL LDX BASPNT
 JSR SKPSPC SKIP OVER SPACES
 BEQ NFIL1 END OF LINE?
 CMPA #': 
 BNE NFIL2
NFIL1 LDX #FNAME PROMPT FOR NAME
 JSR PDATA
 JSR FILBUF ACCEPT INPUT
 LDX #BUFFER POINT TO BUFFER
NFIL2 STX LINPTR SAVE POINTER
 LDX #SYSFCB POINT AT FCB
 STX CURFCB
 LDA #$0F
 STA FNUMBR SET FILE NUMBER 
 JSR GETFIL PARSE FILE NAME
 BCS NFIL4
 LDX #SYSFCB
 TST $0C,X FILE EXTENSION SET?
 BNE NFIL3 THEN SKIP
 LDA #'B SET EXTENSION TO 'BAS'
 STA $0C,X
 LDA #'A
 STA $0D,X
 LDA #'S
 STA $0E,X
NFIL3 RTS 
NFIL4 LDX #BADNAM SAY NAMES NO GOOD
 JSR PSTRNG
 JMP BWARM1

FNAME FCC "FILE NAME? "
 FCB $00

BADNAM FCC "ILLEGAL FILE NAME"
 FCB $00
 PAG
****************************************
*CALL FILE MANAGER
FILEIO JSR FMCALL CALL TO FLEX
 BEQ FILIO3 ERROR?
 LDA $01,X
 CMPA #$08 IS IT EOF?
 BEQ FILIO2
FILIO1 CLR FOFLAG
 CLR FIFLAG
 JSR RPTERR DOS REPORT ERROR
 LDB #$F0
 ORAB FNUMBR FORM ERROR NUMBER
 JMP ERROR BASIC REPORT ERROR
FILIO2 LDA #$08 RETURN EOF
FILIO3 RTS
 PAG
****************************************
*SAVE PROGRAM ON TAPE
*TSAVE[ CHAR]
TSAVE JSR SETPRT SET PORT
 LDA #$12 PUNCH ON
 JSR OUTCHR
 JSR DELAY WAIT FOR SPEED UP
 JSR DELAY
 JSR DELAY
 JSR NULL32 SEND LEADER
 JSR SKPSPC SKIP OVER SPACES
 JSR ISLTR ONE CHAR FILE NAME?
 BCS TSAVE1
 TAB 
 LDA #$04 SEND EOT
 JSR OUTCHR
 TBA FOLLOWED BY CHAR
 JSR OUTCHR
TSAVE1 LDX BEGPTR POINT TO BEGINNING
TSAVE2 CPX ENDPTR AT END?
 BEQ TSAVE3
 LDA #$02 SEND STX
 JSR OUTCHR
 JSR LSTLIN LIST LINE
 LEAX 1,X
 BSR DEL1 KILL TIME
 BRA TSAVE2 LOOP 
TSAVE3 LDA BRKCHR SEND BREAK CHAR
 JSR OUTCHR TO TERMINATE LOAD
 BSR NULL32 SEND TRAILLER
 JMP BWARM1
 PAG
****************************************
*LOAD PROGRAM FROM TAPE
*TLOAD[ CHAR]
TLOAD JSR CLRSRC

****************************************
*APPEND TAPE TO PROGRAM
*TAPPEND[ CHAR]
TAPPND JSR SETPRT
 LDA #$11 READER ON
 STAA LOAFLG
 JSR OUTCHR SEND IT
 JSR SKPSPC SKIP OVER SPACES
 TAB 
 JSR ISLTR GOT FILE NAME?
 BCS TLOAD3
TLOAD1 PSHB 
 LDX INPPTR
 JSR $00,X CALL INPUT ROUTINE
 PULB 
 CMPA #$03 GOT ETX
 BNE TLOAD2
 JSR INCHR
TLOAD2 CMPA #$04 GOT EOT
 BNE TLOAD1
 JSR INCHR GET NAME
 CBA MATCH? 
 BNE TLOAD1 LOOP IF NOT
TLOAD3 JSR INCHR 
TLOAD4 CMPA #$02 GOT STX
 BNE TLOAD3 KEEP LOOKING
 JSR INCHR GET SOURCE BYTE
 JSR ISNUMB LINE NUMBER?
 BCS TLOAD4 NOPE KEEP LOOKING
 LDX #BUFFER
 JSR FILL2 INPUT LINE TO BUFFER
 LDX #BUFFER
 BSR SORTIN SORT INTO MEMORY
 BRA TLOAD3

DELAY BSR DEL1
DEL1 CLRB 
DEL2 CLRA 
DEL3 DECA 
 BNE DEL3
 DECB 
 BNE DEL2
 RTS 

NULL32 LDB #$32
NUL32 LDA #$00
 JSR OUTCHR
 DECB 
 BNE NUL32
 RTS 
 PAG
****************************************
*SORT BASIC LINE INTO SOURCE
SORTIN JSR FINDLN PARSE LINE NUMBER
 JSR FINDNO LOCATE LINE
 BCC DELREP FOUND THEN DELETE-REPLACE
 LDX BUFNXT
 JSR SKPSPC SKIP OVER SPACES
 BEQ REPL1 NULL LINE THEN JUST EXIT
 LDX WORKBA GET WHERE WE SHOULD PUT LINE
 CPX ENDPTR AT END OF SRC?
 BEQ CAPPEN THEN APPEND
 BSR INSLIN JUST INSERT
 BRA REPL1

*DELETE-REPLACE LINE
DELREP LDX BUFNXT
 JSR SKPSPC SKIP OVER SPACES
 BNE RELPLC NOT EMPTY LINE?
 LDX ENDPTR NO LINE TO DELETE?
 CPX BEGPTR
 BEQ REPL1 THEN EXIT
 BSR DELIT DELETE LINE
 BRA REPL1 AND EXIT
RELPLC BSR DELIT REPLACE BY DELETE LINE
 BSR INSLIN THEN INSERT LINE
REPL1 RTS

*APPEND LINE 
CAPPEN BSR INSLIN INSERT LINE
 LDX PAKLIN GET LINE NUM
 STX HILINE SAVE AS NEW HI LINE
 BRA REPL1

*DELETE LINE
DELIT LDX WORKBA POINT TO LINE TO DELETE
 LDY ENDPTR POINT TO END OF PROGRAM
 LEAX 5,X SKIP OVERHEAD BYTES
 LEAY -5,Y FIX COUNT
DELIT1 LDA $00,X+ GET BYTE
 LEAY -1,Y DEC END POINTER
 TSTA END OF LINE? 
 BNE DELIT1
 STY ENDPTR SET NEW END PTR
 STY FREPTR SET FREE MEMORY POINTER
 TFR X,Y POINT Y TO END OF DELETED LINE 
 LDX WORKBA POINT TO START OF DELETED LINE
*MOVE REST OF SOURCE OVER DELETED LINE 
DELIT2 CPX ENDPTR END OF SOURCE?
 BEQ DELIT3
 LDA 0,Y+ MOVE BYTE
 STA 0,X+
 BRA DELIT2
DELIT3 RTS

*INSERT LINE
INSLIN LDX BUFNXT POINT TO NEW LINE
 JSR CMDSCH LOOK UP KEYWORD
 STX KEYWRD SAVE POINTER
 LDX ENDPTR POINT TO END OF SRC
 STX ERRSAV SAVE FOR NOW
 LDB ENDBUF+1 CALC SIZE OF LINE
 SUBB BUFNXT+1
 ADDB #$06 ADD OVERHEAD
 PSHB SAVE SIZE OF INSERT
 ADDB ENDPTR+1 ADD TO END POINTER
 LDA #$00
 ADCA ENDPTR
 CMPA TOPMEM OUT OF MEM?
 BCC NOMEM
 STAB ENDPTR+1 SAVE NEW END POINTER
 STAA ENDPTR
 LDX ENDPTR
 STX FREPTR
 PULB 
 TFR X,Y
 LDX ERRSAV POINT TO OLD END OF SOURCE
*MOVE DATA UP TO MAKE ROOM FOR INSERT
INSL1 CPX WORKBA END OF MOVE?
 BEQ INSL2
 LEAX -1,X
 LDA $00,X
 STA 0,-Y
 BRA INSL1
*
INSL2 LDX WORKBA POINT TO HOLE IN SOURCE
 LDA PAKLIN STUFF LINE NUM INTO SRC. 
 STAA $00,X+
 LDA PAKLIN+1
 STAA $00,X+
 LDA KEYWRD STUFF KEYWORD ADDRESS INTO SRC.
 STAA $00,X+
 LDA KEYWRD+1
 STAA $00,X+
 STAB $00,X+
 LDY BUFNXT POINT TO REST OF LINE
*MOVE LINE INTO HOLE
INSL3 LDA 0,Y+
 STAA $00,X+
 TSTA 
 BNE INSL3
 RTS 
 PAG
NOMEM LDB #$14
 JMP ERROR REPORT ERROR

****************************************
*CONTINUE EXECUTION OF BASIC PROGRAM
*CONT
CONT LDX BASNUM
 STX BASLIN
CONT1 LDX #ASTACK RESET ARITH STACK
 STX PNTRAE
 CLR FIFLAG CLEAR FILE INPUT FLAG
 CLR FOFLAG CLERA FILE OUTPUT FLAG
 LDX STRPTR POINT TO STRING SPACE
 STX SXSAVE
 LDX BASLIN POINT TO CURRENT LINE
 CPX ENDPTR SAME AS END?
 BNE CONT3

CONT2 JMP END THEN STOP

CONT3 LEAX -1,X
 LDA $00,X GET NEXT CHAR
 LEAX 1,X
 CMPA #': END OF LINE?
 BNE CONT4
 STX BASPNT SAVE POINTER TO LINE
 JMP IF07

CONT4 TST BASLIN CHECK HI BYTE OF BUFFER ADDRESS
 BEQ CONT2 IF ZERO (DIRECT MODE) THEN STOP
 STX BASNUM SAVE POINTER TO LINE
 TST TRFLAG TRACE ON?
 BEQ CONT5 SKIP IF NOT
 JSR PUSHX
 JSR SPORT1 SET TO CONTROL PORT
 JSR PULLX
 LDA #'[ PRINT BRACKET
 JSR OUTCHR
 LDA #$20 THEN SPACE
 JSR OUTCHR
 JSR OUT4HS PRINT LINE NUMBER
 LDA #'] THEN RIGHT BRACKET
 JSR OUTCHR
 JSR PCRLF NEW LINE
 BRA CONT6
*CORRECT COUNTER IF NOT TRACE
CONT5 LEAX 1,X
 LEAX 1,X
CONT6 LEAX 3,X 
 STX BASPNT
 LEAX -3,X
 LDX $00,X POINT TO KEYWORD ENTRY
 LDX $00,X GET POINTER TO ROUTINE
 JMP $00,X EXECUTE ROUTINE
 PAG
****************************************
*PROCESS THEN PART OF IF THEN
THEN LDX BASPNT
 JSR SKPSPC SKIP OVER SPACES
 JSR ISNUMB EXPECTING NUMBER
 BCC GOTO CONTINUE WITH GOTO
 JMP IF07

ON0ERR LDB #$20
 JMP ERROR REPORT ERROR

*ON EXPR [GOTO] LINENO[,LINENO]...
*ON EXPR [GOSUB]
ON LDX BASPNT
 JSR EVAL EVALUATE ARGUMENT
 JSR FIX CONVERT TO FIXED POINT
 TSTB ZERO NOT VALID 
 BEQ ON0ERR
 DECB START COUNT WITH 0
 STAB ONLOOP SET GOUNT
 JSR CMDSCH SEARCH COMMAND TABLE
 LDX $00,X GET EXECUTION ADDRESS
 CPX #GOTO
 BEQ GOTO1 GOTO?
 CPX #GOSUB
 BEQ GOS1 GOSUB?
 BRA ON0ERR

*BASIC SUBROUTINE CALL
*GOSUB LINENO
GOSUB CLR ONLOOP SKIP COUNT EQ 0
GOS1 LDX BASLIN 
 JSR NXTLIN POINT TO NEXT LINE
 LDX SUBPTR GET SUB STACK POINTER
 CPX #LOAFLG OVERFLOW?
 BNE GOS2

 LDB #$09
 JMP ERROR REPORT ERROR

GOS2 LDA BASLIN GET POINTER NEXT LINE
 STAA $00,X SAVE ON SUB STACK
 LEAX 1,X
 LDA BASLIN+1
 STAA $00,X
 LEAX 1,X
 STX SUBPTR SAVE SUB POINTER
 BRA GOTO1
 PAG
*UNCONDITIONAL JUMP
*GOTO LINENO 
GOTO CLR ONLOOP SKIP COUNT EQ 0
GOTO1 JSR BRKTST OPERATOR WANT SOMETHING?
 LDX BASPNT
GOTO2 JSR FINDLN GET LINE NUMBER
 DEC ONLOOP SHOULD WE SKIP
 BMI GOTO3
 JSR SKPSPC SKIP OVER SPACES
 CMPA #$2C CHECK FOR SEPERATOR
 BNE ON0ERR
 LEAX 1,X SKIP OVER
 BRA GOTO2 LOOP TILL ON COUNT <0
GOTO3 JSR FINDNO FIND LINE IN SOURCE
 BCC GOTO4

 LDB #$07
 JMP ERROR REPORT ERROR

GOTO4 STX BASLIN MAKE IT THE NEXT LINE
 JMP CONT1 AND EXECUTE IT

*RETURN FROM SUBROUTINE
RETURN LDX SUBPTR GET SUB POINTER
 CPX #SUBSTK EMPTY STACK
 BNE RETRN1

 LDB #$10
 JMP ERROR REPORT ERROR

RETRN1 LEAX -1,X POP ADDRESS OFF STACK
 LEAX -1,X
 STX SUBPTR SAVE NEW STACK PTR.
 LDX $00,X GET LINE ADDRESS
 BRA GOTO4 GOTO IT

*STOP EXECUTING BASIC PROGRAM
STOP JSR SPORT1 SET TO CTL PORT
 LDX #STPMSG PRINT STOP MESSAGE
 JSR PDATA
 JSR OUTSP
 LDX BASLIN PRINT LINE NUMBER
 JSR OUT4HS
 JSR NXTLIN POINT TO NEXT LINE
 STX BASNUM
 JMP BWARM1
 PAG
****************************************
*STORE STRING
STSTOR JSR PUSHX
 LDB #$FF
 STAB STRTRM USE ZERO AS STRING TERM
 BSR FSTRNG FIND START OF WORK STRING
 BSR MSTR1 MOVE IT
 JSR PULLX
 RTS 

*MOVE STRING
MOVSTR CLR STRTRM USE COMMA AS TERM.
MSTR1 STX SXSAVE
 JSR PULLAE
 LDY SXSAVE
 LDX PNTRAE
 LDX $00,X GET POINTER TO VARIBLE
 LDB STRLEN SIZE OF MOVE
MSTR2 LDA 0,Y+ GET SOURCE STRING
 STAA $00,X MOVE TO DEST.
 TST STRTRM 
 BNE MSTR3
 CMPA #', END OF STRING?
 BEQ MSTR4
MSTR3 TSTA
 BEQ MSTR4 END OF NULL TERM STRING
 LEAX 1,X
 DECB COUNT EXAUSTED
 BNE MSTR2
 BRA MSTR5
MSTR4 CLR $00,X CLEAR REST OF DEST. STRING
 LEAY -1,Y
MSTR5 TFR Y,X
 RTS 

*FIND START OF STRING IN WORK SPACE
FSTRNG PSHA 
 LDX SXSAVE GET STRING POINTER
 CPX STRPTR SAME AS START OF STRING SPACE
 BEQ FSTRN2
 LEAX -1,X
FSTRN1 CPX STRPTR END OF SPACE?
 BEQ FSTRN2
 LEAX -1,X DEC POINTER
 LDA $00,X CHECK BYTE
 BNE FSTRN1 LOOP IF NOT ZERO
 LEAX 1,X
FSTRN2 PULA 
 STX SXSAVE
 RTS 
 PAG
****************************************
*INPUT [#EXPR,]["PROMPT",]VAR,VAR,...
INPUT JSR SETPRT SET UP PORT
 LDA BASPNT
 BNE INP1
INPERR LDB #$02
 JMP ERROR REPORT ERROR
INP1 LDX BASPNT
 JSR SKPSPC SKIP OVER SPACES
 CMPA #'" GOT PROMPT STRING?
 BNE INP3
 JSR EVALST EVALUATE IT
 CMPA #', COMMA SEPERATOR?
 BNE INPERR WE GOT ERROR
 LEAX 1,X SKIP COMMA
 STX BASPNT
 JSR REST2
INP3 LDA CURPRT
 CMPA #$0A
 BCS INP5
INP4 STAA LOAFLG
 JSR FILBUF GET DATA FROM FILE
 CLR LOAFLG
 BRA INP6
INP5 JSR PROMPT GET INPUT FROM KEYBOARD
INP6 LDX #BUFFER POINT TO DATA
 STX BUFNXT
 LDX BASPNT
INP7 JSR LET0A TEST FOR VALID VAR.
 BCC INP0E
 STX BASPNT
 LDX BUFNXT
INP8 TST STRFLG LOOKING FOR STRING?
 BNE INP0A
 BSR INNUMB PARSE NUMBER
 BCC INP0B NO  THEN MOVE TO VAR
 TST FIFLAG DOING FILE?
 BNE INP0F THEN GET OUT
 TSTA 
 BEQ INP9
 LDX #RENTR ASK FOR REENTER
 JSR PSTRNG
INP9 JSR PROMPT GET INPUT FROM KEYBOARD
 LDX #BUFFER
 BRA INP8 TRY AGAIN
INP0A JSR SKPSPC SKIP OVER SPACES
 JSR MOVSTR GET STRING
 BRA INP0C
INP0B JSR MOVARV MOVE ARITH STACK TO VAR.
INP0C JSR SKPSPC SKIP OVER SPACES
 CMPA #', CHECK FOR MORE INPUT DATA
 BNE INP0D
 LEAX 1,X
INP0D STX BUFNXT
 LDX BASPNT POINT TO BASIC SRC
 JSR SKPSPC SKIP OVER SPACES
 LEAX 1,X 
 CMPA #', COMMA SEPERATOR
 BEQ INP7 LOOP FOR NEXT VARIBLE
INP0E LEAX -1,X BACK UP ONE
 CLR PRCNT
 CMPA #': END OF LINE?
 BEQ INP0F
 TSTA 
 BNE INP10
INP0F JMP DATA

INP10 LDB #$03
 JMP ERROR REPORT ERROR

*PARSE NUMBER IN BUFFER RESULT ON ARITH STACK
INNUMB JSR SKPSPC SKIP OVER SPACES
 STAA TSIGN
 LEAX 1,X
 CMPA #'-
 BEQ INNUM0
 LEAX -1,X
*PARSE NUMERIC CONSTANT
NUMCON CLR TSIGN
INNUM0 CLRA 
 STAA SIGDIG
 STAA DECFLG
 STAA TOGGLE
 JSR CLRACC
 LDB PNTRAE
 STAB INDEX4
 LDB PNTRAE+1
 STAB INDEX4+1
 LDB #$05
INTST1 JSR SKPSPC SKIP OVER SPACES
 JSR ISNUMB
 BCC INTST3
 CMPA #'.
 BNE INTST2
 STAA DECFLG
 LEAX 1,X
 BRA INTST1
INTST2 SEC 
 RTS 
INTST3 LEAX -1,X
INTST4 LEAX 1,X
 LDA $00,X
 JSR ISNUMB
 BCS MAYEXP
 SUBA #$30
 BNE INTST5
 TST SIGDIG
 BNE INTST6
 TST DECFLG
 BEQ INTST4
 DEC EXPNT
 BRA INTST4
INTST5 STAA SIGDIG
INTST6 JSR PUSHX
 LDX INDEX4
 TSTB 
 BEQ INTST9
 TST TOGGLE
 BNE INTST7
 ADDA $00,X
 STAA $00,X
 LEAX 1,X
 DECB 
 BRA INTST8
INTST7 ASLA 
 ASLA 
 ASLA 
 ASLA 
 STAA $00,X
INTST8 COM TOGGLE
INTST9 STX INDEX4
 TST DECFLG
 BNE INTS0A
 INC EXPNT
INTS0A JSR PULLX
 BRA INTST4
MAYEXP TST DECFLG
 BNE MAYEX1
 CMPA #$2E
 BNE MAYEX1
 STAA DECFLG
 BRA INTST4
MAYEX1 CLRB 
 CMPA #$45
 BNE MAYEX4
 LEAX 1,X
 LDA $00,X
 CMPA #$2D
 BEQ MAYEX3
 CMPA #$2B
 BNE MAYEX2
 LEAX 1,X
MAYEX2 BSR FORMEX
 BRA MAYEX4
MAYEX3 LEAX 1,X
 BSR FORMEX
 NEGB 
MAYEX4 LDA EXPNT
 ABA 
 JSR PUSHX
 LDX PNTRAE
 STAA $06,X
 JSR PUSHAE
 JSR PULLX
 TST TSIGN
 BEQ MAYEXT
 JSR NEGATE
MAYEXT CLC 
 RTS 
 PAG
********************************
*CLEAR ACCUMULATOR
CLRACC JSR PUSHX
 PSHB 
 LDB #$07
 LDX PNTRAE
CLACC1 CLR $00,X
 LEAX 1,X
 DECB 
 BNE CLACC1
 CLR EXPNT
 PULB 
 JSR PULLX
 RTS 

*
FORMEX LDA $00,X
 JSR ISNUMB
 BCC FMEX1
 LDB #$02
 JMP ERROR REPORT ERROR
FMEX1 SUBA #$30
 TAB 
 LEAX 1,X
 LDA $00,X
 JSR ISNUMB
 BCS FMEX2
 ASLB 
 TBA 
 ASLB 
 ASLB 
 ABA 
 TAB 
 LDA $00,X
 SUBA #$30
 ABA 
 TAB 
 LEAX 1,X
FMEX2 RTS
 PAG
****************************************
*READ DATA FROM FILE OR SOURCE
*READ [#FILENUM,]VAR,[VAR,]...
READ JSR CK4DSK
 BCC READ1
 JMP FREAD
READ1 LDX BASPNT
READ2 JSR LET0A TEST FOR VALID VAR.
 BCC READ0C
 STX BASPNT
 LDX DATPNT
 CPX BEGPTR
 BEQ READ8
READ3 TST STRFLG
 BEQ READ5
 JSR SKPSPC SKIP OVER SPACES
 BEQ READ7
 CMPA #$22
 BEQ READ4
 JSR MOVSTR
 BRA READ0A
READ4 STX DATPNT
 LDX STRPTR
 STX SXSAVE
 LDX DATPNT
 JSR STREVL
 BCS READ6
 JSR STSTOR
 BRA READ0A
READ5 JSR INNUMB
 BCC READ9
READ6 NOP 
 LDA $00,X
 BEQ READ7
RDERRX LDB #$19
 JMP ERROR REPORT ERROR
READ7 CPX ENDPTR
 BEQ RDERRX
 LDA $00,X
 LEAX 1,X
 TSTA 
 BNE READ7
READ8 LDA $03,X
 CMPA #DATTOK
 BNE READ7
 LEAX 5,X
 BRA READ3
READ9 JSR MOVARV MOVE ARITH STACK TO VAR.
READ0A LDA $00,X
 CMPA #$2C
 BNE READ0B
 LEAX 1,X
READ0B STX DATPNT
 LDX BASPNT
 JSR SKPSPC SKIP OVER SPACES
 LEAX 1,X
 CMPA #$2C
 BEQ READ2
READ0C LEAX -1,X
 CMPA #$3A
 BEQ READ0D
 TSTA 
 BNE RDERRX
READ0D JMP DATA
 PAG
****************************************
*RESTORE DATA POINTER OR FILE POINTER
*RESTORE [#FILENUM]
RESTOR JSR CK4DSK
 BCC REST1
 JMP RESTDK
REST1 LDX BEGPTR
 STX DATPNT
 LDX BASPNT
 JMP DATA
REST2 JSR PUSHX
 JSR FSTRNG FIND START OF WORK STRING
REST3 LDA $00,X
 BEQ REST4
 JSR OUTCHA
 LEAX 1,X
 BRA REST3
REST4 JSR PULLX
 RTS 
 PAG
****************************************
*SET PORT TO CONTROL PORT
SPORT1 LDA CURPRT
 BRA SPRT3

*SET PORT FOR I/O
SETPRT LDX BASPNT POINT TO LINE
 JSR SKPSPC SKIP OVER SPACES
 CMPA #'# PORT NUMBER FOLLOWS?
 BNE SPORT1 NO SET TO CTL PORT
 LEAX 1,X
 JSR EVAL EXVALUATE PORT NUMBER
 BEQ SPRT2
 CMPA #', DELIMITER?
 BEQ SPRT1 CONTINUE
 CMPA #'; DELIMITER?
 BEQ SPRT1
 CMPA #': END OF LINE?
 BEQ SPRT2
 JMP LET04 SINTAX ERROR
SPRT1 LEAX 1,X SKIP DELIMITER
SPRT2 STX BASPNT SAVE POINTER
 JSR FIX CONVERT NUMBER TO FIXED POINT
 TBA 
SPRT3 CMPA #$08 PORT NUMBER OUT OF RANGE
 BCS SPRT4
 CLR PORADR THEN CLEAR ADDRESS HI
 STAA PORADR+1 SAVE AS LOW
 LDA #$09 FAKE PORT NUMBER
 TAB 
 ASLA 
 ASLA 
 BRA SPRT6
SPRT4 TAB SAVE PORT NUMBER
 ASLA MULT BY 2 
 ASLA MULT BY 4
 CMPA PORADR+1 SAME AS LAST TIME
 BNE SPRT5 THEN SKIP SETUP
 RTS 
SPRT5 PSHA
 STAA PORADR+1 SET LSB OF PORT ADDRESS
 LDA #$E0 
 STAA PORADR SET MSB
 PULA 
SPRT6 ASLA NOW EQ PORT TIMES 8
 ABA PLUS ONE=NINE TIMES
 LDX #JMPPT0 POINT TO BASE OF TABLE
 STX OUTPTR SET POINTER
 STX INPPTR 
 ADDA OUTPTR+1 ADD PORTNUM*9 TO ADDRESSS
 STAA OUTPTR+1
 ADDA #$03
 STAA INPPTR+1 SET IN POINTER 
 LDA PORADR
 BEQ INITPT ALWAYS INIT PORT 0
 LDX PORADR GET ADDRESS
 LDA $01,X TEST FOR VALID ACIA/PIA
 CMPA #$FF
 BNE INITPT INIT PORT

 LDB #$26 EMPTY PORT
 JMP ERROR REPORT ERROR

INITPT LDX INPPTR
 LEAX 3,X INIT PORT AT INPORT+3
 JSR $00,X CALL INIT PORT SUBROUTINE
 RTS 
 PAG
****************************************
*PRINT [#PORT,][VAR,][FUNC,][VAR,]...
PRINT JSR SETPRT SET PORT
 LDX BASPNT
PRINT1 JSR SKPSPC SKIP OVER SPACES
 CMPA #': NULL LINE?
 BEQ PRINT2
 TSTA 
 BNE PRINT5
PRINT2 LEAX -1,X
 LDA $00,X
 LEAX 1,X
 CMPA #'; END LINE WITH CRLF?
 BEQ PRINT3
 JSR PCRLF
 CLR PRCNT COLUMN EQ ZERO
PRINT3 LEAX 1,X
 STX BASLIN
 JMP CONT1 CONTINUE EXECUTION
PRINT4 JMP ERROR REPORT ERROR

*TAB TO SPECFIED COLUMN
TAB JSR PARSEX GET ARGUMENT
 JSR PULLX1
 JSR FIX CONVERT TO FIXED PT.
 DECB 
 SUBB PRCNT SUB CURRENT COLUMN
 BLE TAB2
TAB1 JSR OUTSP AND SPACE THAT MANY TIMES
 DECB 
 BNE TAB1
TAB2 LDS TOPMEM CLEAN UP STACK
 BRA PRINT7 KEEP PRINTING

PRINT5 JSR EVALST EVALUATE STRING
 TST STRFLG 
 BNE PRINT6BRANCH IF GOT STRING
 BSR PRNUMB PRINT NUMBER
 BRA PRINT7 KEEP TRYING
PRINT6 JSR REST2
PRINT7 JSR SKPSPC SKIP OVER SPACES
 CMPA #', CHECK SEPERATOR 
 BNE PRINT9
 LEAX 1,X SKIP OVER
PRINT8 LDA PRCNT CHECK COLUMN
 TAB 
 ANDB #$F0 TAB STOPS AT 16 CHAR
 SBA 
 BEQ PRINTA AT NEW COL?
 JSR OUTSP SPACE OVER
 BRA PRINT8 LOOP TILL DONE
PRINT9 CMPA #'; SEPERATOR NO TABING?
 BNE PRINTB
 LEAX 1,X SKIP OVER
PRINTA LDA PORADR IF PORT ADDRESS=0
 BNE PRINT1 THEN WERE DOING FILE IO
 LDA #$2C SO SEND COMMA SEP TO FILE
 BSR OUTCHA
 BRA PRINT1
PRINTB TSTA END OF LINE IF ZERO
 BEQ PRINT1
 CMPA #': ALSO END OF LINE
 BEQ PRINT1
 LDB #$06 THIS IS NOT GOOD
 BRA PRINT4

OUTDOT LDA #'. SEND A PERIOD
 BRA OUTCHA

OUTZER CLRA SEND A ZERO

OUTDIG ANDA #$0F SEND A DIGIT
 ADDA #$30
OUTCHA PSHA SEND A CHARACTER 
 JSR OUTCHR
 PULA 
 TST FOFLAG DOING FILE?
 BNE OUTZ1 SKIP IF FILE
 CMPA #$20 SENDING SPACE?
 BCC ENLINE THEN CHECK IF TIME TO WRAP LINE
OUTZ1 RTS
ENLINE PSHB 
 LDB PRCNT GET CUR COLUMN
 INCB BUMP IT
 TST LINLEN LENGTH NOT DEFINED?
 BEQ ENLN2
 CMPB COLWID
 BCS ENLN2
 CMPB LINLEN CURRENT COLUMN >MAX LINE LEN
 BCC ENLN1
 CMPA #$20
 BNE ENLN2
ENLN1 JSR PCRLF SO END LINE
 CLRB 
ENLN2 STAB PRCNT SAVE COLUMN
 PULB 
 RTS 

*PRINT NUMBER
PRNUMB JSR PUSHX
 LDA DIGFLG
 STAA PRTDIG
 JSR PULLAE
 CLRA 
 STAA DECFLG
 TST $00,X
 BNE PRNUM2
 TST PRTDIG
 BNE PRNUM4
 BSR OUTZER
PRNUM1 JSR PULLX
 TST FOFLAG
 BNE OUTZ1
 JMP OUTSP
PRNUM2 TST $00,X
 BPL PRNUM3
 LDA #$2D
 BSR OUTCHA
 JSR NEGA1
PRNUM3 LDA $06,X
 CMPA #$09
 BGT PNUM0A
 CMPA #$FF
 BLT PNUM0A
 TSTA 
 BGT PRNUM6
PRNUM4 BSR OUTZER
 BSR OUTDOT
 STAA DECFLG
PRNUM5 TST $06,X
 BPL PRNUM9
 BSR OUTZER
 DEC PRTDIG
 BEQ PRNUM1
 INC $06,X
 BRA PRNUM5
PRNUM6 TST DECFLG
 BNE PRNUM9
PRNUM7 LDA $00,X
 JSR OUTDIG
 JSR ALLEFT
 DEC $06,X
 BNE PRNUM7
 TST PRTDIG
 BNE PRNUM8
 BSR TSTZER
 BCC PRNUM1
PRNUM8 JSR OUTDOT
PRNUM9 BSR PRTAIL
 BRA PRNUM1
PNUM0A LDA $00,X
 JSR OUTDIG
 JSR ALLEFT
 JSR OUTDOT
 BSR PRTAIL
 LDA #$45
 JSR OUTCHA
 LDB $06,X
 CMPA #$3A
 BEQ PNUM0B
 DECB 
 BPL PNUM0C
PNUM0B LDA #$2D
 JSR OUTCHA
 NEGB 
PNUM0C CLRA 
PNUM0D INCA 
 SUBB #$0A
 BPL PNUM0D
 DECA 
 ADDB #$0A
 JSR OUTDIG
 TBA 
 JSR OUTDIG
 JMP PRNUM1

PRTAIL LDB PRTDIG
PTAIL1 BSR TSTZER
 BCC PTAIL3
PTAIL2 LDA $00,X
 JSR OUTDIG
 JSR ALLEFT
 DECB 
 BNE PTAIL1
 BRA PTAIL4
PTAIL3 TST DIGFLG
 BNE PTAIL2
PTAIL4 RTS 
 PAG
****************************************
*TEST ACCUMULATOR FOR ZERO
TSTZER JSR PUSHX
 LDX PNTRAE GET POINTER TO VALUE
 PSHB 
 LDB #$06 SET DIGIT COUNT
TZER1 TST $00,X CHECK DIGIT
 BNE TZER2 GOT SOMETHING?
 LEAX 1,X POINT TO NEXT
 DECB 
 BNE TZER1 TRY IT
 CLC 
 BRA TZER3
TZER2 SEC
TZER3 JSR PULLX
 PULB 
 RTS 
 PAG
****************************************
*LET VAR=EXPR
LET0A JSR TSTVAR TEST FOR VALID VARIBLE NAME
 BCS LET01 REPORT ERROR
 SEC 
 RTS 

LET LDX BASPNT
 BSR LET0A TEST FOR VALID VAR.
 BCS LET03

LET01 LDB #$12
LET02 JMP ERROR REPORT ERROR

LET03 JSR SKPSPC SKIP OVER SPACES
 LEAX 1,X
 CMPA #'= LOOK FOR EQUAL SIGN
 BEQ LET05
LET04 LDB #$06 ELSE ITS AN ERROR
 BRA LET02
LET05 TST STRFLG LOOKING FOR A STRING?
 BNE LET07
 JSR EVAL EVALUATE EXPRESSION
 CMPA #': END OF LINE?
 BEQ LET06
 TSTA CHECK FOR END OF LINE
 BNE LET04
LET06 JSR MOVARV MOVE ARITH STACK TO VAR.
 BRA DATA NO-OP REST OF LINE

LET07 JSR EVALST EVALUATE STRING EXPRESSION
 TST STRFLG STILL STRING?
 BNE LET08
 JMP CONCA3 FINISH UP IN CONCAT
LET08 CMPA #':
 BEQ LET09 END OF LINE?
 TSTA END OF LINE?
 BNE LET04
LET09 JSR STSTOR ASSIGN STRING TO VARIBLE
 BRA DATA
 PAG
****************************************
*SET CONTROL PORT NUMBER
*PORT=EXPRESSION
PORT LDX BASPNT
 JSR EVAL EVALUATE ARGUMENT
 JSR FIX CONVERT TO FIXED PT.
 TBA 
 JSR SPRT3 SETUP POINTERS TO PORT
 LDX BASPNT
 STAB CURPRT SAVE NUMBER
 BRA DATA

*SET NUMBER OF DIGITS FOR PRINT
*DIGITS=EXPR
DIGITS LDX BASPNT
 JSR EVAL
 JSR FIX
 CMPB #$0A TOO LARGE?
 BCS DIGIT1
 LDB #$09 THEN FORCE TO MAX
DIGIT1 STAB DIGFLG SAVE SIZE
 BRA DATA

*TRACE ON 
TRON LDA #$FF
 STAA TRFLAG SET TRACE FLAG
 BRA DATA

*TRACE OFF
TROFF CLR TRFLAG
 BRA DATA

*REMARK
REMARK JSR FINEOL FIND END OF LINE
 BRA DATA1

DATA JSR NXTLIN SKIP TO END OF LINE
DATA1 JMP CONT1
 PAG
****************************************
*GET PARAMETER
GETPAR JSR PUSHX
 LDX BASPNT
 JSR EVAL EVALUATE EXPRESSION
 LEAX 1,X
 CMPA #', COMMA SEPERATOR
 BEQ GPAR1
 CMPA #') RIGHT PAREN
 BNE DIM02 ERROR
 STX BASPNT
 JSR PULLX
 CLC 
 RTS 
GPAR1 JSR PAREXP PARSE NEXT ARGUMENT
 STX BASPNT
 JSR PULLX
 SEC 
 RTS 
 PAG
****************************************
*DIM VAR(EXPR[,EXPR])[,VAR...]
DIM LDX BASPNT
DIM01 CLR STRFLG
 JSR FINVAR
 BVS DIM02
 BCS DIM03

DIM02 LDB #$05
 JMP ERROR REPORT ERROR

DIM03 TSTA 
 BPL DIM02
 STX BASPNT
 LDX VARPTR
 STAB $00,X
 STAA $01,X
 BSR GETPAR
 BCC DIM04
 JSR FIX
 BRA DIM05
DIM04 CLRB 
DIM05 STAB $03,X
 JSR FIX
 TBA 
 STAA $02,X
 BSR ALLOCV
 LDX BASPNT
 JSR SKPSPC SKIP OVER SPACES
 LEAX 1,X
 CMPA #$2C
 BEQ DIM01
 LEAX -1,X
 JMP DATA

*ALLOCATE VARIBLE
ALLOCV JSR PUSHX
 LDB $01,X
 CMPB #$A4 STRING ARRAY?
 BNE DIM07
 STAB STRFLG
DIM07 LDB $03,X
 BSR RESERV ALLOC SPACE FOR ARRAY
 TST STRFLG
 BEQ DIM08
 JSR STRNGM RESERVE SPACE FOR STRING
DIM08 JSR INX6 
 STX FREPTR
 JSR PULLX
 LDA FREPTR
 STAA $04,X
 LDA FREPTR+1
 STAA $05,X
 RTS 

*RESERVE SPACE FOR ARRAY
RESERV TSTA 
 BNE DIM0B
DIM0A LDB #$15
 JMP ERROR REPORT ERROR
DIM0B CMPA $02,X
 BHI DIM0A
 CMPB $03,X
 BHI DIM0A
 PSHA 
 LDA $02,X
 STAA ANUM
 TSTB 
 BEQ DIM0F
DIM0C DECB 
 BEQ DIM0F
 LDA ANUM
DIM0D JSR INX6
 TST STRFLG
 BEQ DIM0E
 JSR STRNGM
DIM0E DECA 
 BNE DIM0D
 BRA DIM0C
DIM0F PULA 
DIM10 JSR INX6
 TST STRFLG
 BEQ DIM11
 JSR STRNGM
DIM11 DECA 
 BNE DIM10
 RTS 
 PAG
****************************************
*FOR VAR=EXPR TO EXPR [STEP EXPR]
FOR LDX BASPNT
 JSR LET0A GET VARIBLE POINTER
 BCS FOR02
FOR01 JMP LET01 REPORT ERROR
FOR02 TST STRFLG
 BNE FOR01 CANT BE STRING
 STX BASPNT
 JSR NXTLIN FIND START OF NEXT LINE
 LDX PNTRAE
 JSR DEX7
 LDA $00,X GET VARIBLE NAME
 LDB $01,X
 STAA ANUM
 STAB BNUM
 LDX #FORSTK POINT TO FOR-NEXT STACK
FOR03 LDA ANUM
 LDB BNUM
 CPX FORPTR END OF STACK?
 BEQ FOR05
 CMPA $00,X GOT RIGHT VARIBLE
 BNE FOR04
 CMPB $01,X
 BNE FOR04
 LDA BASLIN
 LDB BASLIN+1
 CMPA $0E,X
 BNE FOR04
 CMPB $0F,X
 BEQ FOR05
FOR04 JSR INX8 SKIP TO NEXT ENTRY
 JSR INX8
 BRA FOR03
FOR05 CPX #PRGEND NO ROOM LEFT?
 BNE FOR06
 LDB #$16
 JMP ERROR REPORT ERROR

FOR06 LDA ANUM
 LDB BNUM
 STAA $00,X
 LEAX 1,X
 STAB $00,X
 LEAX 1,X
 STX FORPTR
 LDX BASPNT
 JSR SKPSPC SKIP OVER SPACES
 LEAX 1,X
 CMPA #$3D
 BEQ FOR08
FOR07 JMP LET04
FOR08 JSR EVAL
 JSR MOVARV MOVE ARITH STACK TO VAR.
 JSR TOSCH
 CPX #TOTOKN
 BNE FOR07
 LDX BASPNT
 JSR EVAL
 STX BASPNT
 LDX FORPTR
 JSR MOVARX MOVE ARITH STACK TO X
 JSR INX6
 STX FORPTR
 LDX BASPNT
 JSR TOSCH
 CPX #LSTCMD+1
 BNE FOR09
 LDX BASPNT
 JSR EVAL
 STX BASPNT
 BRA FOR0A
FOR09 JSR ACCEQ1
FOR0A LDX FORPTR
 JSR MOVARX MOVE ARITH STACK TO X
 JSR INX6
 STX FORPTR
 LDX BASPNT
 JSR SKPSPC SKIP OVER SPACES
 CMPA #$3A
 BEQ FOR0C
 TSTA 
FOR0B BNE FOR07
FOR0C LEAX 1,X
 STX BASLIN
 LDX FORPTR
 LDB BASLIN
 STAB $00,X
 LEAX 1,X
 LDB BASLIN+1
 STAB $00,X
 LEAX 1,X
 STX FORPTR
 JMP CONT1
 PAG
****************************************
*NEXT VAR
NEXT LDX BASPNT
 JSR LET0A TEST FOR VALID VAR.
 BCS NEXT1
 JMP LET01 REPORT ERROR
NEXT1 JSR SKPSPC SKIP OVER SPACES
 CMPA #': END OF LINE?
 BEQ NEXT2
 TSTA 
 BNE FOR0B
NEXT2 LEAX 1,X
 STX BASLIN
 JSR PULLAE
 LDA $00,X GET VARIBLE POINTER
 LDB $01,X
 LDX FORPTR
 CPX #FORSTK
 BEQ NEXT8
NEXT3 STX FORPTR
 CPX #FORSTK
 BEQ NEXT7
 JSR DEX8
 JSR DEX8
 CMPA $00,X CHECK FOR VARIBLE MATCH
 BNE NEXT3
 CMPB $01,X
 BNE NEXT3
 STX FORNOW SET POINTER
 LDX $00,X POINT TO VARIBLE
 JSR MOVXAR MOVE X TO ARITH STACK
 LDX FORNOW
 JSR INX8 POINT TO INC VALUE
 LDA #$02
 TST $00,X
 BPL NEXT4
 ADDA #$03 
NEXT4 STAA TEMPIF SET COMPARISON TYPE
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR ADD ADD INC TO VARIBLE
 LDX #FORTMP POINT TO TEMP
 JSR MOVARX MOVE ARITH STACK TO X
 JSR PUSHAE
 LDX FORNOW
 LEAX 1,X POINT TO LOOP TERM VALUE
 LEAX 1,X
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR IF10 DO END OF LOOP TEST
 BCC NEXT6 
 LDX FORNOW 
 STX FORPTR
NEXT5 JMP CONT1 TERM REACHED GOTO NEXT LINE
NEXT6 LDX #FORTMP
 JSR MOVXAR MOVE X TO ARITH STACK
 LDX FORNOW
 LDX $00,X
 JSR MOVARX MOVE ARITH STACK TO X
 LDX FORNOW
 LDX $0E,X
 STX BASLIN SET UP NEXT LINE
 BRA NEXT5 AND CONTINUE
NEXT7 LDB #$18
 BRA NEXT9
NEXT8 LDB #$17
NEXT9 JMP ERROR REPORT ERROR
 PAG
****************************************
*IF EXPR RELOP EXPR THEN [STATEMENT]
*                        [LINE NO]
IF LDX BASPNT
 JSR EVALST
 BSR RELOPR
 STAA TEMPIF
 TST STRFLG
 BEQ IF05
 JSR EVALST
 TST STRFLG
 BNE IF01
 JMP CONCA3
IF01 STX BASPNT
 JSR FSTRNG FIND START OF WORK STRING
 STX ERRSAV
 JSR FSTRNG FIND START OF WORK STRING
 TFR X,Y
 LDX ERRSAV
IF02 LDA 0,Y+
 TSTA
 BEQ IF03
 SUBA $00,X
 BNE IF04
 LEAX 1,X
 BRA IF02
IF03 LDA $00,X
IF04 BSR IF11
 BRA IF06
IF05 JSR EVAL
 STX BASPNT
 BSR IF10
IF06 BCC IF07
 JMP REMARK
IF07 LDX BASPNT
 JSR CMDSCH SEARCH COMMAND LOOKUP TABLE
 LDX $00,X
 JMP $00,X EXECUTE COMMAND

*DECODE RELATIONAL OPERATOR
RELOPR JSR SKPSPC SKIP OVER SPACES
 LEAX 1,X GET CHARACTER
 CMPA #'= EQUAL?
 BNE IF09
 LDA #$00 EQUAL
 RTS

IF09 LDB $00,X
 CMPA #'< LESS THAN?
 BNE IF0D
 CMPB #'= LESS THAN OR EQ?
 BNE IF0A
 LEAX 1,X
 LDA #$02 LESS OR EQUAL
 RTS 

IF0A CMPB #'> GREATER THAN? <>
 BNE IF0C
IF0B LEAX 1,X
 LDA #$03 GREATER THAN
 RTS 

IF0C LDA #$01 LESS THAN
 RTS 

IF0D CMPA #'> GREATER THAN?
 BEQ IF0E

 LDB #$06
 JMP ERROR REPORT ERROR

IF0E CMPB #'< NOT EQUAL?
 BNE IF0F
 LEAX 1,X
 LDA #$05 NOT EQUAL
 RTS 

IF0F CMPB #'< 
 BEQ IF0B
 LDA #$04 GREATER THAN OR EQ
 RTS 

IF10 JSR SUB SUBTRACT TO GET CC
 JSR PULLAE
 LDA $00,X GET SIGN
IF11 PSHA 
 LDA TEMPIF GET COMPARISON CODE
 ASLA 
 ASLA MULT BY 4
 LDX #BRTABL
 LEAX A,X OFFSET INTO TABLE
 PULA RECOVER SIGN
 TSTA SET CC
 JMP $00,X GOTO BRANCH TEST
*IF CONDITIONAL BRANCH TABLE
BRTABL BEQ BRCLC 0 EQUAL
 BRA BRSEC

 BMI BRCLC 1 LESS THAN
 BRA BRSEC

 BMI BRCLC 2 LESS THAN OR EQUAL
 BRA BRTABL

 BNE BRCLC 3 GREATER THAN
 BRA BRSEC

 BEQ BRSEC 4 GREATER THAN OR EQUAL
 BMI BRSEC

 BPL BRCLC 5 NOT EQUAL
BRSEC SEC 
 RTS 

BRCLC CLC
 RTS 
 PAG
****************************************
*FUNCTION USER(EXPR)
USER JSR PARSAE EVALUATE ARGUMENT
 JSR PUSHX PUSH POINTER
 LDX USRPTR
 JSR $00,X EXECUTE USER ROUTINE
 JSR PULLX POP POINTER
USER01 RTS

**************************************** 
*FUNCTION INTEGER
* INT(EXPR)
INTGER JSR PARSAE
INTEG1 LDB #$09
 SUBB $06,X
INTEG2 TSTB 
 BLE INTEG3
 JSR LRIGHT
 INC $06,X
 DECB 
 BRA INTEG2
INTEG3 CLR $05,X
 JSR PUSHAE
 JSR NORMAL
 JSR PULLAE
 RTS 

****************************************
*FUNCTION SIGN
* SIGN(EXPR)
SIGN BSR PARSAE
 LDA $00,X
 BEQ SIGN2
 STAA TSIGN
 JSR ACCEQ1
 JSR PULLAE
 TST TSIGN
 BPL SIGN2
SIGN1 JSR NEGA1
SIGN2 RTS

****************************************
*FUNCTION ABSOLUTE VALUE
* ABS(EXPR)
ABS BSR PARSAE
 TST $00,X
 BPL SIGN2
 BRA SIGN1

****************************************
*FUNCTION RANDOM NUMBER
* RND(EXPR)
RND LDX BASPNT
 JSR SKPSPC SKIP OVER SPACES
 CMPA #$28
 BNE RNDM1
 LEAX 1,X
 STX BASPNT
 BSR PARSAE
 JSR TSTZER
 BCC RNDM1
 JSR PUSHAE
 BRA RNDM2
RNDM1 LDX #RNDOMN
 INC $00,X
 JSR MOVXAR MOVE X TO ARITH STACK
RNDM2 LDX #CONS2
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR MULT
 JSR PULLAE
 JSR ALLEFT
 LDA $01,X
 PSHA 
 LDA $03,X
 STAA $01,X
 PULA 
 STAA $03,X
 CLR $06,X
 JSR PUSHAE
 JSR NORMAL
 LDX #RNDOMN
 JSR MOVARX MOVE ARITH STACK TO X
 RTS 

PARSAE BSR PARSEX
 JSR PULLAE
 RTS 

PARSEX LDX BASPNT
 JSR PAREXP
 STX BASPNT
 RTS 

****************************************
*WRITE BYTE TO MEMORY
*POKE(BYTE,ADDRESS)
POKE JSR GETPAR
 BCS POKE1
 JMP PARERR
POKE1 JSR FIX
 PSHB 
 JSR DFIX
 STAB BNUM
 STAA ANUM
 LDX ANUM
 PULB 
 STAB $00,X
 LDX BASPNT
 JMP DATA

****************************************
*FUNCTION POSITION
* POS 
POSITN LDA PRCNT
 INCA 
 BSR FLOAT
 RTS 
****************************************
*GET BYTE FROM MEMORY-PEEK
*PEEK(ADRESS)
PEEK BSR PARSEX
 JSR DFIX
 STAB BNUM
 STAA ANUM
 LDX ANUM
 LDA $00,X
 BSR FLOAT
 RTS 

*CONVERT BYTE TO FLOATING POINT
FLOAT JSR PUSHX
 LDX PNTRAE
 JSR CLRACC
 LDB #$09
 STAB $06,X
 CLRB 
FLOAT1 SUBA #$64
 INCB 
 BCC FLOAT1
 DECB 
 ADDA #$64
 STAB $04,X
 JSR LLEFT
 CLRB 
FLOAT2 SUBA #$0A
 INCB 
 BCC FLOAT2
 DECB 
 ADDA #$0A
 ADDB $04,X
 STAB $04,X
 JSR LLEFT
 ADDA $04,X
 STAA $04,X
 JSR PUSHAE
 JSR NORMAL
 JSR PULLAE
 JSR PULLX
 RTS 

****************************************
*FUNCTION ASCII
* ASC(STRINGVAR)
ASCII BSR VAL4
 LDA $00,X
 LEAX 1,X
 CMPA #$29
 BEQ ASCII1
 JMP PARERR
ASCII1 STX BASPNT
 JSR FSTRNG FIND START OF WORK STRING
 LDA $00,X
 JSR FLOAT
 CLR STRFLG
 RTS 

****************************************
* FUNCTION LENGTH OF STRING
* LEN(STRINGVAR)
LENGTH BSR ASCII
 CLRA 
LENTH1 INCA 
 LDB $00,X
 LEAX 1,X
 TSTB 
 BNE LENTH1
 DECA 
 JSR FLOAT
 RTS 

****************************************
*FUNCTION VALUE OF STRING
VALUE BSR ASCII
 JSR INNUMB
 BCC VAL1
 LDB #$27
 JMP ERROR REPORT ERROR
VAL1 JSR PULLAE
 RTS 
VAL2 BSR VAL4
 JSR SKPSPC SKIP OVER SPACES
 CMPA #$2C
 BEQ VAL3
 JMP PARER2
VAL3 LEAX 1,X
 STX BASPNT
 RTS 
VAL4 LDX BASPNT
 JSR EVALST
 TST STRFLG
 BNE VAL5
 JMP CONCA3
VAL5 RTS
 
****************************************
*FUNCTION LEFT PART OF STRING
* LEFT$(STRINGEXPR,LENGTH)
LEFT BSR VAL2
 JSR PAREXP
 STX BASPNT
 JSR FIX
 INCB 
 PSHB 
 CMPB #$80
 BCC MIDST2
 BRA MIDST4

****************************************
*FUNCTION MID PART OF STRING
* MID$(STRING,START,LENGTH)
MIDSTR BSR VAL2
 JSR GETPAR
 LDB #$7F
 BCC MIDST1
 JSR FIX
MIDST1 CMPB #$80
 BCS MIDST3
MIDST2 LDB #$25
 JMP ERROR REPORT ERROR
MIDST3 INCB 
 PSHB 
 JSR FIX
 CMPB #$80
 BCC MIDST2
 TBA 
 DECA 
MIDST4 JSR FSTRNG FIND START OF WORK STRING
MIDST5 LEAX 1,X
 DECA 
 BPL MIDST5
 LEAX -1,X
 PULA 
 DECA 
 TFR X,Y
 LDX SXSAVE
MIDST6 TSTA
 BMI MIDST7
 LDB 0,Y+
 STAB $00,X+
 DECA 
 TSTB
 BNE MIDST6
MIDST7 CLR -1,X
MIDST8 STX SXSAVE
 LDB #$FF
 STAB STRFLG
 JSR PULLAE
 RTS 

****************************************
*FUNCTION RIGHT PART OF STRING
* RIGHT$(STRINGVAR,LENGTH)
RIGHT JSR VAL2
 JSR PAREXP
 STX BASPNT
 JSR FIX
 CMPB #$80
 BCC MIDST2
 JSR FSTRNG FIND START OF WORK STRING
 PSHB 
RGT01 LDB $00,X
 LEAX 1,X
 INCA 
 TSTB 
 BNE RGT01
 DECA 
 PULB 
 PSHA 
 SBA 
 BPL RGT02
 CLRA 
RGT02 TAB
 LDX SXSAVE
 BRA MIDST5

***************************************
*FUNCTION CONVERT NUMERIC TO CHARACTER
* CHR$(EXPR)
CHR JSR PARSEX
 JSR FIX
 LDX SXSAVE
 STAB $00,X
 LEAX 1,X
 CLR $00,X
 LEAX 1,X
 BRA MIDST8

***************************************
*SET LENGTH OF LINE
*LINE=EXPR
LINEEQ LDX BASPNT
 JSR EVAL
 JSR FIX
 STAB LINLEN
 TBA 
 ASRB 
 ASRB 
 SBA 
 INCA 
 STAA COLWID
 JMP DATA

****************************************
*SET MAXIMUM LENGTH OF STRING
*STRING=EXPR
STRING JSR GETPAR
 BCC STRNG1
 JMP CONCA3
STRNG1 LDX OUTPTR
 JSR PUSHX
 LDA PRCNT
 PSHA 
 LDX #STRNG2
 STX OUTPTR
 JSR PRNUMB
 PULA 
 STAA PRCNT
 JSR PULLX
 STX OUTPTR
 LDX SXSAVE
 LEAX -1,X
 CLR $00,X
 LEAX 1,X
 JMP MIDST8
STRNG2 LDX SXSAVE
 STAA $00,X
 LEAX 1,X
 STX SXSAVE
 RTS 

****************************************
*DEFINE USER FUNCTION
*DEF FNX=STATEMENT
DEF LDX BASPNT
 JSR SKPSPC SKIP OVER SPACES
 BEQ DEF5
 CMPA #$46
 BNE DEF5
 LEAX 1,X
 LDA $00,X
 CMPA #$4E
 BNE DEF5
 LEAX 1,X
 LDA $00,X
 JSR ISLTR
 BCS DEF5
 JSR SKIP1
 CMPA #$28
 BNE DEF5
 JSR SKIP1
 BPL DEF1
 JMP DATA
DEF1 ORAA #$80
 STAA $00,X
 JSR FINVAR
 BVS DEF5
 ANDB #$7F
 STAB BNUM
 STAA ANUM
 STX BASPNT
 LDX VARPTR
 STAB $00,X
 LDX BASPNT
 JSR SKPSPC SKIP OVER SPACES
 CMPA #$29
 BNE DEF5
 JSR SKIP1
 CMPA #$3D
 BNE DEF5
DEF2 LEAX 1,X
 LDB $00,X
 CMPB #$3A
 BEQ DEF4
 TSTB 
 BEQ DEF4
 CMPB BNUM
 BNE DEF2
 LDA $01,X
 JSR ISNUMB
 BCC DEF3
 LDA #$20
DEF3 CMPA ANUM
 BNE DEF2
 ORAB #$80
 STAB $00,X
 BRA DEF2
DEF4 LEAX -1,X
 JMP DATA
DEF5 LDB #$22
 JMP ERROR REPORT ERROR

****************************************
*EXECUTE USER DEFINED FUNCTION
FNX LDX BASPNT
 LDB $00,X
 JSR SKIP1
 CMPA #$28
 BNE FNX04
 LEAX 1,X
 JSR PUSHX
 LDX BEGPTR
FNX01 CPX ENDPTR
 BEQ FNX04
 LEAX 1,X
 LEAX 1,X
 LEAX 1,X
 LDA $00,X
 LEAX 1,X
 CMPA #$99
 BEQ FNX03
FNX02 JSR FEOL1
 BRA FNX01
FNX03 JSR SKIP1
 LEAX 1,X
 LEAX 1,X
 LDA $00,X
 CBA 
 BNE FNX02
 JSR SKIP1
 LEAX 1,X
 JSR TSTVAR
 BCS FNX04
 JSR SKIP1
 JSR SKIP1
 STX INDEX3
 JSR PULLX
 JSR PAREXP
 JSR MOVARV MOVE ARITH STACK TO VAR.
 JSR PUSHX
 LDX INDEX3
 JSR EVAL
 JSR PULLAE
 JSR PULLX
 STX BASPNT
 RTS 
FNX04 LDB #$23
 JMP ERROR REPORT ERROR

*
REDUCE JSR PARSEX
 BSR AEDUPE
 LDX #TWOPIE
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR DIVIDE
 JSR PULLAE
 JSR INTEG1
 JSR PUSHAE
 LDX #TWOPIE
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR MULT
 JSR SUB
 JSR AEDUPE
 LDX #PIE
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR SUB
 JSR PULLAE
 TST $00,X
 BMI REDXIT
 LDX #TWOPIE
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR SUB
REDXIT RTS 

****************************************
*FUNCTION TANGENT
* TAN(EXPR)
TANGNT BSR SINE
 JSR PUSHAE
 BSR COS1
 TST $00,X
 BNE TAN1
 LDA #$01
 STAA $00,X
 LDA #$9A
 STAA $06,X
TAN1 JSR PUSHAE
 JSR DIVIDE
 JSR RESULT
 RTS 

*SQUARE VALUE IN ACCUMULATOR
ACCSQR BSR AEDUPE
 BSR AEDUPE
 JSR MULT
 LDX #TANACC
 JSR MOVARX MOVE ARITH STACK TO X
 RTS 

*DUPLICATE VALUE ON STACK
AEDUPE LDX PNTRAE
 JSR DEX7
AEDUP1 LDA $00,X
 STAA $07,X
 LEAX 1,X
 CPX PNTRAE
 BNE AEDUP1
 JMP PUSHAE
*
ACCSAV LDX #TRNACC
 JSR MOVARX MOVE ARITH STACK TO X
 JSR CLRACC
 JSR PUSHAE
 RTS
 
***************************************
*FUNCTION SINE
* SIN(EXPR)
SINE JSR REDUCE
 BSR ACCSQR
 BSR ACCSAV
 LDB #$07
 LDX #SINTBL
 BSR SERIES
 BRA RESULT

***************************************
*FUNCTION COSINE
* COS(EXPR)
COSINE JSR REDUCE
 BSR ACCSQR
 JSR PULLAE
COS1 JSR ACCEQ1
 BSR ACCSAV
 LDB #$07
 LDX #COSTBL
 BSR SERIES
 BSR RESULT
 LDA $06,X
 CMPA #$FA
 BGE COSXIT
 JSR CLRACC
COSXIT RTS
 
*SUBROUTINE CALCULATE THE SERIES 
SERIES STX COSXSV SAVE POINTER
 PSHB SAVE COUNT
 LDX #TANACC POINT TO ACCUM.
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR MULT MULTIPLY
 LDX COSXSV RECOVER POINTER
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR DEX6 MOVE TO NEXT IN SERIES
 JSR ADD ADD IT
 PULB 
 DECB LAST IN SERIES? 
 BNE SERIES
 LDX #TRNACC
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR MULT
 RTS

*SUBROUTINE SAVE THE RESULT 
RESULT JSR CLRACC
 LDX PNTRAE
 JSR DEX7
 LDB $06,X
 STAB $0D,X
 TST $00,X
 BEQ RESUL1
 LDB #$50
 STAB $0B,X
 JSR PUSHAE
 JSR ADD
RESUL1 JSR PULLAE
 CLR $04,X
 RTS 

*FUNCTION LOGRYTHM
* LOG(EXPR)
LOG JSR PARSEX EVALUATE ARGUMENT
LOG1 JSR CLRACC SET ACCUM TO ZERO
 LDX PNTRAE GET POINTER TO ACCUM
 JSR DEX7
 LDA $06,X
 LDB #$01
 STAB $06,X
 STAB LOGSGN
 LDB $00,X
 BLE LOG6
 CMPB #$03
 BCS LOG2
 CLR $06,X
 CLR LOGSGN
LOG2 JSR PUSHAE
LOG3 LDX #TWO302
 CMPA LOGSGN
 BEQ LOG5
 BPL LOG4
 PSHA 
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR SUB
 PULA 
 INCA 
 BRA LOG3
LOG4 PSHA 
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR ADD
 PULA 
 DECA 
 BRA LOG3

LOG5 LDX #LOGACC
 JSR MOVARX MOVE ARITH STACK TO X
 BSR ACCEQ1 SET ACCUM EQ 1
 JSR SUB SUBTRACT
 JSR AEDUPE DUP TOP OF STACK
 BSR ACCEQ2 SET ACCUM EQ 2
 JSR ADD ADD IT
 JSR DIVIDE DIVIDE
 JSR ACCSQR SQUARE IT
 JSR ACCSAV SAVE RESULT
 LDAB #$09 SIZE OF TABLE
 LDX #LOGTBL POINTER TO TABLE
 JSR SERIES PROCESS SERIES
 BSR ACCEQ2 SET ACCUM EQ 2
 JSR MULT MILTILPY BY TWO
 LDX #LOGACC POINT TO ACCUM
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR ADD ADD
 JSR PULLAE POP POINTER
 RTS
 
LOG6 LDAB #$28
 JMP ERROR REPORT ERROR

*SUBROUTINE SET ACCUMULATOR EUQAL TO 1.00
ACCEQ1 LDX PNTRAE POINT TO ACCUM
 JSR CLRACC CLEAR IT
 LDAA #$01 SET TO ONE
 STAA $00,X SET MS DIGIT
ACCXPN STAA $06,X SET EXPONENT
 JSR PUSHAE
 RTS 

*SUBROUTINE SET ACCUMULATOR EQUAL TO 2.00
ACCEQ2 LDX PNTRAE GET POINTER TO RESULT
 JSR CLRACC CLEAR IT
 LDAA #$02 SET MS DIGIT EQ 2
 STAA $00,X
 DECA SET EXPONENT TO 1
 BRA ACCXPN

****************************************
*E TO THE ARG POWER
* EXP(EXPR)
EXP JSR PARSEX
*ANTILOG
EXP01 JSR AEDUPE DUP TOP OF STACK
 LDX #TWO302 POINT TO 2.302
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR DIVIDE DIVIDE
 JSR PULLAE
 JSR INTEG1 TRUNCATE TO INTEGER
 LDAB $00,X
 JSR PUSHAE
 JSR AEDUPE DUP TOP OF STACK
 TSTB 
 BPL EXP02
 JSR NEGATE NEGATE TOP OF STACK
 JSR FIX CONVERT TO FIXED POINT
 NEGB NEGATE RESULT 
 BRA EXP03
EXP02 JSR FIX CVT TO FIXED
EXP03 PSHB 
 LDX #TWO302 POINT TO 2.302
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR MULT MULTIPLY
 JSR SUB SUBTRACT
 LDX #TWO500
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR MULT MULT BY 2.5
 LDX #TANACC POINT TO ACCUMULATOR
 JSR MOVARX MOVE ARITH STACK TO X
 JSR ACCEQ1 SET TO 1
 JSR ACCSAV SAVE IT
 LDAB #$0A TABLE SIZE
 LDX #EXPTBL POINT TO TABLE
 JSR SERIES PROCESS SERIES
 JSR AEDUPE DUP TOP OF STACK
 JSR MULT SQUARE IT
 JSR AEDUPE
 JSR MULT SQUARE IT AGAIN
 JSR RESULT
 PULB 
 ADDB $06,X
 STAB $06,X
 RTS 

****************************************
*FUNCTION SQUARE ROOT
* SQR(EXPR)
SQROOT JSR PARSAE EVALUATE ARGUMENT
 TST $00,X
 BNE ROOT1 CANT DO ROOT OF ZERO
 RTS 
ROOT1 JSR PUSHAE
 JSR LOG1 DO LOG OF ARG
 JSR PUSHAE SAVE IT
 LDX #ROOTBL POINT TO TABLE
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR MULT MULTIPLY LOG BY .5
 JMP EXP01 DO ANTILOG

****************************************
*FUNCTION ARCTANGENT
* ATAN(EXPR)
ARCTAN JSR PARSEX EVALUATE ARGUMENT
 JSR ACCEQ1 SET ACCUMULATOR EQ 1
 JSR PULLAE
 JSR PULLAE
 LDAA $00,X CHECK SIGN
 PSHA 
 BPL ATAN1 SKIP IF POSITIVE
 JSR NEGA1 NEGATE ARGUMENT
ATAN1 CLR SGNFLG
 LDAA $06,X CHECK EXPONENT SIGN
 BLE ATAN2
 STAA SGNFLG SET NEG FLAG
 JSR SWAP SWAP TOS WITH TOS+1
ATAN2 JSR PUSHAE
 JSR PUSHAE
 JSR DIVIDE DIVIDE
 JSR ACCSQR SQUARE ACCUM
 JSR ACCSAV SAVE IT
 LDAB #$07 SET COUNT
 LDX #ATNTBL POINT TO TABLE
 JSR SERIES PROCESS SERIES
 TST SGNFLG TEST NEG FLAG
 BEQ ATAN3
 JSR NEGATE NEGATE ACCUMULATOR
 LDX #HALFPI
 JSR MOVXAR MOVE X TO ARITH STACK
 JSR ADD ADD PI/2 TO ACCUM
ATAN3 PULA TEST SIGN
 TSTA 
 BPL ATAN4
 JSR NEGATE NEGATE RESULT
ATAN4 JMP RESULT

***************************************
*END STATEMENT
END JSR FMSCLS CLOSE FILES
 JMP BWARM1 GOTO WARM START

*SUBROUTINE SETUP FILE NUMBER
PRONUM LDX BASPNT
 JSR SKPSPC SKIP OVER SPACES
 BEQ PRON1 NO NUMBER?
 CMPA #': END OF LINE?
 BEQ PRON1
 CMPA #'# NUMBER FOLLOWS?
 BNE PRON2
 INX 
 JSR EVAL EVALUATE EXPRESSION
 STX BASPNT
 JSR FIX CONVERT TO FIXED POINT
 CMPB #$09
 BHI PRON2
 STAB FNUMBR SET FILE NUMBER
 CLC 
 RTS
 
PRON1 SEC NO NUMBER SET 
 RTS
 
PRON2 LDAB #$30
 JMP ERROR REPORT ERROR

*SUBROUTINE CHECK TERMINATOR
CKTERM LDX BASPNT
 JSR SKPSPC SKIP OVER SPACES
 BEQ CKTRM4
 CMPA #': END OF LINE?
 BEQ CKTRM4
 CMPA #', COMMA?
 BEQ CKTRM1
 CMPA #'; SEMICOLON?
 BNE CKTRM2
CKTRM1 INX SKIP SEPERATOR 
CKTRM2 CLC NOT END OF LINE
CKTRM3 STX BASPNT
 RTS
 
CKTRM4 SEC END OF LINE FOUND 
 BRA CKTRM3

*SET DISK FILE NAME IN FCB
PRONAM JSR SKPSPC SKIP OVER SPACES
 BEQ PRONU2
 STX LINPTR
 LDX CURFCB POINT TO FCB
 JSR GETFIL MOVE NAME TO FCB
 BCS PRONU2
 LDX CURFCB
 LDAA #$07
 JSR SETEXT SET DEFAULT EXTENTION
PRONU1 LDX LINPTR
 RTS 
PRONU2 SEC 
 RTS

*SUBROUTINE FIND FILE BLOCK 
FNDFCB LDX #FCBLST POINT TO FCB LIST
 LDAB FNUMBR GET FILE NUMBER
 BEQ FFCB2
 ASLB 
FFCB1 INX ADD B TO X
 DECB 
 BNE FFCB1
FFCB2 STX CURFCB SAVE POINTER TO POINTER
 RTS 
 PAG
****************************************
*OPEN FILE
*OPEN #FILENUM,FILENAME
OPEN JSR PRONUM PARSE FILE NUMBER
 BCC OPEN1
 JMP OPEN6 BAD NUMBER
OPEN1 JSR FNDFCB LOCATE FILE BLOCK
 LDX $00,X 
 BNE OPEN3 POINTER NOT ZERO
 LDX FREPTR
 LDAA #'% FLAG AS FILE BLOCK
 STAA $00,X
 LDAA #$80 TREAT LIKE ARRAY
 ORAA FNUMBR SET FILE NUMBER
 STAA $01,X
 LDA #$46 ALLOCATE FILE BLOCK
 LDB #$01
 ADDA FREPTR+1 RESERVE MEMORY
 ADCB FREPTR
 CMPB STRPTR NOT ENOUGH ROOM?
 BCS OPEN2

 LDAB #$14 OUT OF MEMORY
 JMP ERROR REPORT ERROR

OPEN2 STAB $04,X SET POINTER TO NEXT FREE
 STAA $05,X
 STAB FREPTR SAME HERE
 STAA FREPTR+1
 LDAB #$06
 JSR ADDBX FORM POINTER TO START OF FILE BLOCK
 STX IOXSAV AFTER HOUSE KEEP BYTES
 LDX CURFCB
 LDAA IOXSAV
 STAA $00,X
 LDAA IOXSAV+1
 STAA $01,X
 LDX IOXSAV
OPEN3 STX CURFCB
 TST $02,X
 BNE OPEN5
 JSR FIXSTR SET FILE NAME
 LDX CURFCB
 LDAA #$80 MARK FCB NOT OPEN
 STAA $02,X
 JSR CKTERM
 BCS OPEN4
 JMP OPEN LOOP FOR NEXT FILE
OPEN4 JMP DATA
OPEN5 LDAB #$32
 BRA OPEN7
OPEN6 LDAB #$03
 BRA OPEN7
 LDAB #$31
OPEN7 JMP ERROR REPORT ERROR

***************************************
*CLOSE OPEN FILE
*CLOSE #FILENUM[,#FILENUM]
CLOSE JSR SETFNU SET FILE NUMBER
 LDAA $02,X CHECK FILE STATUS
 BMI CLOSE1 NEVER OPENED?
 BEQ CLOSE2 ALREADY CLOSED
 BSR CLOSE3 CLOSE IT
CLOSE1 CLR $02,X MARK FCB NOT ACTIVE
 JSR CKTERM END OF LINE?
 BCC CLOSE
 JMP DATA EXIT

CLOSE2 LDAB #$29
 JMP ERROR REPORT ERROR

CLOSE3 LDX CURFCB
 LDAA #$04 CLOSE FILE FUNCTION
 STAA $00,X
 JMP FILEIO DO IT

****************************************
*READ FROM FILE
*READ #FILENUM,VAR[,VAR]...
FREAD JSR PRONUM SET FILE NUMBER
 BCS OPEN6
 JSR FNDFCB LOCATE FCB
 LDX $00,X
 BEQ CLOSE2 NOT OPEN?
 STX CURFCB
 LDAA $02,X GET STATUS
 BMI FREAD1
 CMPA #$01 OPEN FOR READ?
 BNE FREAD3
 BRA FREAD2 ALREADY OPEN
FREAD1 LDAA #$01 OPEN READ FUNCTION
 STAA $00,X
 JSR FILEIO CALL FILE MANAGER
FREAD2 LDAA #$0F
 STAA FIFLAG FLAG FILE INPUT
 JSR CKTERM END OF LINE?
 BCS FREAD4
 JMP INP4

FREAD3 LDAB #$34
 JMP ERROR REPORT ERROR

FREAD4 LDAB #$03
 JMP ERROR REPORT ERROR

*SUBROUTINE CHECK FOR DISK
*IF # FOUND ASSUME DISK FILE NUMBER FOLLOWS 
CK4DSK LDX BASPNT
 JSR SKPSPC SKIP OVER SPACES
 BEQ CK4DK1
 CMPA #': END OF LINE?
 BEQ CK4DK3
 CMPA #'# NUMBER SIGN
 BEQ CK4DK2
CK4DK1 CLC
 RTS 
CK4DK2 SEC 
CK4DK3 RTS 

***************************************
*FUNCTION END OF FILE TEST
* EOF(FILENUM)
EOF JSR PARSEX EVAL FILE NUMBER
 JSR DFIX CVT TO FIXED POINT
 STAB FNUMBR SET FILE NUMBER
 JSR SFNUM1
 LDAA $01,X GET FILE STATUS
 CMPA #$08 END OF FILE
 BNE EOF1
 LDAA #$01 RETURN 1
 BRA EOF2
EOF1 CLRA RETURN 0
EOF2 JSR FLOAT
 RTS
 
*GET FILE NAME 
FIXSTR JSR CKTERM END OF LINE
 BCS FXSTR4
 LDAA $01,X
 CMPA #'$ GOT A STRING VAR?
 BNE FXSTR1
 JSR TSTVAR LOCATE IT
 BVS FXSTR4
 STX BASPNT
 LDX VARPTR SET POINER TO IT
 JSR PRONAM MOVE IT TO FCB
 BRA FXSTR2
*LITERAL STRING
FXSTR1 LDX BASPNT POINT TO LINE
 JSR PRONAM MOVE NAME TO FCB
 DEX BACK UP TO TERMINATOR 
 STX BASPNT
FXSTR2 BCS FXSTR3
 RTS
 
FXSTR3 LDAB #$31
 BRA FXSTR5

FXSTR4 LDAB #$03
FXSTR5 JMP ERROR REPORT ERROR

*SUBROUTINE SET FILE NUMBER
SETFNU JSR PRONUM GET NUMBER
 BCS SFNUM2
SFNUM1 JSR FNDFCB LOCATE FCB
 LDX $00,X CHECK ACTIVITY
 BEQ SFNUM3 NOT OPEN?
 STX CURFCB
 RTS 
SFNUM2 LDAB #$30
 BRA FXSTR5
SFNUM3 LDAB #$29
 BRA FXSTR5

****************************************
*RESTORE DISK FILE (REWIND)
*RESTORE #FILENUM[,#FILENUM]...
RESTDK BSR SETFNU SET FILE NUMBER
 LDAA $02,X
 BMI RESTD1 NOT OPEN?
 JSR CLOSE3 CLOSE FILE
RESTD1 LDX CURFCB
 LDAA #$01 OPEN FOR READ
 STAA $00,X
 STAA FIFLAG
 JSR FILEIO CALL FMS
 JSR CKTERM
 BCC RESTDK LOOP FOR NEXT FILE
 JMP DATA
 PAG
****************************************
*KILL FILE (DELETE)
*KILL FILENAME
KILL LDX #SYSFCB POINT TO FCB
 STX CURFCB
 LDAA #$0F
 STAA FNUMBR SET BASIC FILE NUMBER
 JSR FIXSTR GET FILE NAME
 LDAA #$0C DELETE
 LDX CURFCB
 STAA $00,X
 JSR FILEIO CALL FMS
 JMP DATA
 PAG
****************************************
*WRITE DATA TO FILE
*WRITE #FILENUM,VAR,[VAR,]...
WRITE JSR SETFNU SET FILE NUMBER
 LDAA $02,X CHECK ACTIVE FLAG
 BMI WRITE1 NOT OPEN?
 CMPA #$02 OPEN FOR WRITE?
 BNE WRITE8 THEN ERROR
 BRA WRITE2 ALREADY OPEN
WRITE1 LDAA #$02 OPEN FOR WRITE
 STAA $00,X
 JSR FILEIO CALL FILE MANAGER
WRITE2 LDAA #$0F MARK AS OPEN
 STAA FOFLAG
 LDX BASPNT
 JSR CKTERM ANYTHING ELSE ON LINE
 BCS WRITE7
WRITE3 JSR EVALST CHECK FOR STRING
 TST STRFLG
 BNE WRITE4
 JSR PRNUMB SEND NUMBER TO FILE
 BRA WRITE5
WRITE4 JSR REST2 WRITE STRING
WRITE5 STX BASPNT
 JSR CKTERM END OF LINE?
 BCS WRITE6
 LDAA #$2C SEND SEPARATOR TO FILE
 JSR OUTCHR
 BRA WRITE3
WRITE6 LDAA #$0D SEND END OF RECORD
 JSR OUTCHR
 CLR FOFLAG
 JMP DATA

WRITE7 LDAB #$03
 BRA WRITE9
WRITE8 LDAB #$33
WRITE9 JMP ERROR REPORT ERROR
 PAG
****************************************
*SCRATCH FILE
*SCRATCH FILENAME[,FILENAME]...
SCRAT JSR SETFNU SET FILE NUMBER
 LDAA $02,X CHECK ACTIVITY FLAG
 BPL SCRAT3 IN USE?
 LDAA #$0C DELETE FILE
 STAA $00,X
 JSR FMCALL CALL FMS
 BEQ SCRAT1
 LDAA $01,X
 CMPA #$04
 BEQ SCRAT1
 JMP FILIO1 REPORT ERROR
SCRAT1 LDAB #$0B SIZE OF FILE NAME
SCRAT2 LDAA $24,X RECOVER FILE NAME
 STAA $04,X
 INX 
 DECB 
 BNE SCRAT2
 LDX CURFCB
 LDAA #$02 OPEN FOR WRITE
 STAA $00,X
 JSR FILEIO
 JSR CKTERM
 BCC SCRAT LOOP IF NOT DONE
 JMP DATA
SCRAT3 LDAB #$32
 JMP ERROR REPORT ERROR

*RENAME FILE
*RENAME OLDNAME,NEWNAME
RENAME LDX #SYSFCB POINT TO FILE BLOCK
 STX CURFCB
 LDAA #$0F
 STAA FNUMBR SET BASIC FILE NUMBER
 JSR FIXSTR GET FILE NAME
 LDX #FCBXXX POINT TO TEMP NAME
 STX CURFCB
 JSR FIXSTR GET NEW NAME
 LDX #SYSFCB
 STX CURFCB
 LDAA #$0D RENAME
 STAA $00,X
 JSR FILEIO CALL FILE MANAGER
 JMP DATA
 PAG
****************************************
*LIST CATALOG OF DISK
*CAT[ DRIVE]
CATLOG JSR CKTERM END OF LINE?
 BCS CAT1
 JSR EVAL EVALUATE DRIVE NUMBER
 STX BASPNT
 JSR FIX CONVERT TO FIXED POINT
 BRA CAT2
CAT1 LDAB WRKDRV ELSE GET WORK DRIVE NUMBER
CAT2 LDX #SYSFCB POINT TO FILE BLOCK
 CLR $02,X MAKE NOT ACTIVE
 STAB $03,X SET DRIVE NUMBER
 LDAA #$0F
 STAA FNUMBR SET BASIC FILE NUMBER
 STX CURFCB MAKE CURRENT FCB
 LDAA #$06 OPEN DIR
 STAA $00,X
 JSR FILEIO CALL FILE MANAGER
CAT3 JSR PCRLF
CAT4 LDX #SYSFCB
 LDAA #$07 GET DIR ENTRY
 STAA $00,X
 JSR FMCALL CALL FILE MANAGER
 BNE CAT5
 TST $04,X CHECK NAME
 BEQ CAT6 NEVER USED?
 BMI CAT4 DELETED?
 LDX #FCBNAM POINT TO NAME
 LDAB #$08 SET FIELD WIDTH
 BSR CAT7 PRINT NAME
 LDAA #$2E PRINT PERIOD
 JSR OUTCHR
 LDAB #$03 SET FIELD WIDTH
 BSR CAT7 PRINT EXTENTION
 BRA CAT3 LOOP FOR NEXT 
CAT5 LDAA $01,X GET ERROR CODE
 CMPA #$08 END OF FILE?
 BEQ CAT6
 JMP FILIO1 REPORT ERROR
CAT6 JMP DATA END OF DIR EXIT
CAT7 LDAA $00,X+ GET CHAR
 BNE CAT8 IF NULL THEN PRINT SPACE
 LDAA #$20
CAT8 JSR OUTCHR PRINT IT
 DECB 
 BNE CAT7
 RTS
 PAG
****************************************
*ARC TANGENT CONSTANT TABLE
 FCB $09,$99,$99,$61,$00,$00
 FCB $96,$66,$82,$62,$00,$00
 FCB $01,$98,$07,$87,$00,$00
 FCB $98,$67,$66,$49,$00,$00
 FCB $07,$96,$26,$32,$00,$FF
 FCB $96,$63,$93,$73,$00,$FF
ATNTBL FCB $06,$81,$24,$11,$00,$FE

CONS2 FCB $08,$37,$25,$41,$69,$00

HALFPI FCB $01,$57,$07,$96,$32,$01

PIE FCB $03,$14,$15,$92,$65,$01

TWOPIE FCB $06,$28,$31,$85,$30,$01

TWO500 FCB $02,$50,$00,$00,$00,$00

TWO302 FCB $02,$30,$25,$85,$10,$01

*LOG CONSTANT TABLE
 FCB $01,$00,$00,$00,$00,$01
 FCB $03,$33,$33,$33,$33,$00
 FCB $02,$00,$00,$00,$00,$00
 FCB $01,$42,$85,$71,$43,$00
 FCB $01,$11,$11,$11,$11,$00
 FCB $09,$09,$09,$09,$09,$FF
 FCB $07,$69,$23,$07,$69,$FF
 FCB $06,$66,$66,$66,$67,$FF
LOGTBL FCB $05,$88,$23,$52,$94,$FF
*SINE CONSTANT TABLE
 FCB $01,$00,$00,$00,$00,$01
 FCB $98,$33,$33,$33,$33,$00
 FCB $08,$33,$33,$33,$33,$FE
 FCB $98,$01,$58,$73,$02,$FD
 FCB $02,$75,$57,$31,$92,$FB
 FCB $97,$49,$47,$89,$16,$F9
SINTBL FCB $01,$60,$59,$04,$38,$F7

*COSINE CONSTANT TABLE
 FCB $01,$00,$00,$00,$00,$01
 FCB $95,$00,$00,$00,$00,$00
 FCB $04,$16,$66,$66,$67,$FF
 FCB $98,$61,$11,$11,$11,$FE
 FCB $02,$48,$01,$58,$73,$FC
 FCB $97,$24,$42,$68,$08,$FA
COSTBL FCB $02,$08,$76,$75,$70,$F8

*SQUARE ROOT CONSTANT TABLE
 FCB $01,$00,$00,$00,$00,$01
 FCB $01,$00,$00,$00,$00,$01
ROOTBL FCB $05,$00,$00,$00,$00,$00

*EXP CONSTANT TABLE
 FCB $01,$66,$66,$66,$67,$00
 FCB $04,$16,$66,$66,$67,$FF
 FCB $08,$33,$33,$33,$33,$FE
 FCB $01,$38,$88,$88,$89,$FE
 FCB $01,$98,$41,$26,$98,$FD
 FCB $02,$48,$01,$58,$73,$FC
EXPTBL FCB $02,$75,$57,$31,$92,$FB

FCBLST RMB $14
ASTACK RMB 18*7
FORSTK RMB $80
PRGEND EQU *
 PAG
****************************************
*LINKS INTO SYSTEM
ARSTAK EQU $C07F 
SYSFCB EQU $C840
FCBNAM EQU $C844
FCBXXX EQU $C871
TTYBS EQU $CC00
TTYDEL EQU $CC01
TTYBE EQU $CC07
WRKDRV EQU $CC0C
DRVTYP EQU $CC0D
LINPTR EQU $CC14
ESCRET EQU $CC16
MEMEND EQU $CC2B
FLEX EQU $CD03
GETCHR EQU $CD15
PUTCHR EQU $CD18
FPCRLF EQU $CD24
GETFIL EQU $CD2D
SETEXT EQU $CD33
ADDBX EQU $CD36
RPTERR EQU $CD3F
FMSCLS EQU $D403
FMCALL EQU $D406
STATCK EQU $CD4E
 END BASIC
                                                                                                        