BreakKey = &60

	; DB 20180226 - munged to compare with sweh version prior to port to 6809

\ > 6502.Serial65/src
\ Source for Single Port Tube Client MOS for 6502
\ ===============================================
\ This code may be freely reused, with acknowledgements

\ This implements a Tube client communicating with a host
\ via a single port, such as a serial port, a parallel port,
\ or even a single Tube register, all in less than 2K.

\ The link is a text channel that escapes out to send commands
\ and receive data transfers. This version assumes a clean,
\ error-free link channel

\ Can be built as a BBC filing system, with code to access
\ BBC memory map.

\ v0.16 16-Nov-2010 J.G.Harston
\ v0.17 09-Mar-2013 JGH
	Added additional Tube entry points,
\                        EXECUTE enters code with A=0/1, SEC/CLC.
\ v0.18 07-Apr-2013 JGH
	Moved some code that overlapped I/O area.
\       09-Nov-2016 JGH
	Edited slightly to allow conversion to as65 source.
\ v0.19 11-Nov-2016 JGH
	Added conditionals for sideways ROM code.
\ v0.20 18-Mar-2017 JGH
	Added option for local RDLINE, optimised OSCLI.
\ v0.21 23-Feb-2018 JGH
	*HOSTFS ON sets WRCHV/RDCHV.
\                        Serv3 responds to returned boot option.


	

\ System vectors
\ ==============
USERV = &200
BRKV = &202
IRQ1V = &204
IRQ2V = &206
CLIV = &208
BYTEV = &20A
WORDV = &20C
WRCHV = &20E
RDCHV = &210
FILEV = &212
ARGSV = &214
BGetV = &216
BPutV = &218
GBPBV = &21A
FINDV = &21C
FSCV = &21E
EVNTV = &220
UPTV = &222
NETV = &224
VduV = &226
KEYV = &228
INSV = &22A
RemV = &22C
CNPV = &22E
IND1V = &230
IND2V = &232
IND3V = &234

SWROM=1

	DEFFNerror
	IF SWROM%
	[OPT P*3+4
	JSR Error
	]
	=opt% ELSE [OPT P*3+4
	BRK
	]
	=opt%




	IF NOT SWROM
\ System addresses
\ ================
ROMSTART=&F800         \ Start of ROM code to copy to RAM
IOSPACE =&FEF0         \ Start of I/O space
ERRBUF = &236             \ Error buffer
INPBUF = &236
INPEND = &300 \ Supervisor string buffer
PROG = &EE\ &EE/F = PROG   - Current program
NUM = &F0\ &F0/1 = NUM    - hex accumulator
MEMTOP = &F2\ &F2/3 = MEMTOP - top of memory
TRANS = &F4\ &F4/5 = ADDR   - Data transfer address (assembler doesn't like 'INC ADDR')
TRANShi = &F6\ &F6/7 = ADDR+2 - Data transfer address high word
LPTR = &F8\ &F8/9 = String pointer, ummOSWORD control block
CTRL = &FA\ &FA/B = CTRL   - ummOSFILE, ummOSGBPB control block
CMD = &FA\         CMD    - Address of command line parameters
TEXT = &FA\ &FA/B = TEXT   - PrText string pointer
IRQA = &FC\ &FC   = IRQ A store
FAULT = &FD\ &FD/E => last error
ESCFLG = &FF\ &FF   = Escape flag
\ I/O values, these are suitable for a 6850
\ =========================================
TxStatus = &FEF0
TxRDY = 2
TxData = &FEF1
TxInit = &13
RxStop = &55\ &13=Reset ACIA, &55=8N1, clock/16, RTS high
RxStatus = &FEF0
RxRDY = 1
RxData = &FEF1
RxInit = &55
RxCont = &15\ &55=RTS high, &15=RTS low

	ELSE
\ Memory addresses for filing system
\ ==================================
ERRBUF = &100
INPBUF = &100
INPEND = &180

PROG = &C0\ &EE/F = PROG   - Current program
NUM = &C2\ &F0/1 = NUM    - hex accumulator
MEMTOP = &C4\ &F2/3 = MEMTOP - top of memory
TRANS = &C6\ &F4/5 = ADDR   - Data transfer address (assembler doesn't like 'INC ADDR')
TRANShi = &C8\ &F6/7 = ADDR+2 - Data transfer address high word
LPTR = &CA\ &F8/9 = String pointer, ummOSWORD control block
CTRL = &CC\ &FA/B = CTRL   - ummOSFILE, ummOSGBPB control block
CMD = &CE\         CMD    - Address of command line parameters
TEXT = &F6\ &FA/B = TEXT   - PrText string pointer
IRQA = &FC\ &FC   = IRQ A store
FAULT = &FD\ &FD/E => last error
ESCFLG = &FF\ &FF   = Escape flag
\ I/O values for on-board 6850 serial port
\ ========================================
TxStatus = &FE08
TxRDY = 2
TxData = &FE09
TxInit = &13
RxInit = &55\ &13=Reset ACIA, &55=8N1, clock/16, RTS high
RxStatus = &FE08
RxRDY = 1
RxData = &FE09
RxStop = &55
RxCont = &15\ &55=RTS high, &15=RTS low

	ENDIF


\ Serial Tube system values
\ =========================
esc = &9B


\ OS Entry Addresses
\ ==================
ummOSRDCH = &FFE0
ummOSASCI = &FFE3
ummOSNEWL = &FFE7
ummOSWRCH = &FFEE
ummOSWORD = &FFF1
OSBYTE = &FFF4
OSCLI = &FFF7
ummNVWRCH = &FFCB


\ Filing System values
\ ====================
myfs = 9
chanlo = &80
chanhi = &9F




	ORG &8000
.start
\ ----------
\ ROM HEADER
\ ----------
	JMP Language
	JMP Service
	EQUB &82
	EQUB Copyright-$8000
	VERSION_BYTE
.hostfs_name
	VERSION_NAME
	EQUB 0
	VERSION_STRING
	EQUS " ("
	VERSION_DATA
	EQUS ")"
.Copyright
	BRK
	EQUS "(C)JGH+DOB"
	BRK

.Language
	JSR HostFSOn
	JMP STARTUP2   \ Enter with A=0

\ ----------------
\ SERVICE ROUTINES
\ ----------------
.Service
	CMP #1
	BEQ Serv1
	CMP #3
	BEQ Serv3
	CMP #4
	BEQ Serv4
	CMP #&09
	BNE *+5
	JMP Serv9
	CMP #&0F
	BNE *+5
	JMP ServF
	CMP #&10
	BNE *+5
	JMP Serv10
	CMP #&12
	BNE *+5
	JMP Serv12
	CMP #&25
	BNE *+5
	JMP Serv25
	RTS

\ --------------------------------------
\ SERVICE 1 - Claim workspace/initialise
\ --------------------------------------
.Serv1
	RTS

\ ---------------------------------------
\ SERVICE 3 - Boot filing system on Break
\ ---------------------------------------
.Serv3
	TYA
	PHA
	LDA #&7A
	JSR OSBYTE \ Get key pressed
	CPX #&FF
	BEQ Serv3Select    \ Nothing pressed
	CPX #BreakKey
	BEQ Serv3Select    \ TAB-Break
	PLA
	TAY
	LDA #3
	RTS
.Serv3Select
IF	CHECK_RTS
	\ If no RTS, do not select us
	JSR	TestRTS
	BNE	SelectMyFilesystem
	LDY	#0
.skiplp
	LDA	skipfstxt,Y
	BEQ	notMyFilesystem
	JSR	ummOSWRCH
	INY
	BNE	skiplp
.skipfstxt
	EQUS	"UPURSFS not selected; no RTS"
	EQUB	10,13,10,13,0	
ENDIF
.SelectMyFilesystem
	JSR SelectFS
	JSR Serv9a      \ Select FS, print title
	JSR ummOSNEWL
	PLA
	BNE Serv3Ok   \ No boot
	TAY
	TAX
	LDA #&FF
	JSR CallFSCV\ Pass 'Booting' to host, Y=0
	TYA
	AND #3
	BEQ Serv3Ok       \ Y=0, no Boot needed
	TYA
	LDA Serv3Boot-1,Y
	TAX    \ XY=>Boot command
	LDY #Serv3Boot DIV 256
	JSR ummOS_CLI
.Serv3Ok
	LDA #0
	RTS                   \ Claim

.Serv3Boot
	EQUB (Serv3Boot+3) AND 255
	EQUB (Serv3Boot+5) AND 255
	EQUB (Serv3Boot+11) AND 255
	EQUS "L.!BOOT"
	EQUB 13       \ Opt 1 and 2
	EQUS "E.!BOOT"
	EQUB 13       \ Opt 3

\ --------------------
\ SERVICE 4 - *Command
\ --------------------
.Serv4
	TYA
	PHA
	DEY
	LDX #&FF
.Serv4Lp
	INX
	INY
	LDA (&F2),Y
	CMP #'.'
	BEQ Serv4Dot
	CMP #'!'
	BCC Serv4End
	CMP Serv25Table,X
	BEQ Serv4Lp \ Match with Filing System command
	EOR #&20
	CMP Serv25Table,X
	BEQ Serv4Lp
.Serv4Quit
	PLA
	TAY
	LDA #4
	RTS
.Serv4End
	LDA Serv25Table,X
	CMP #32
	BNE Serv4Quit         \ Check for end of command
	DEY
.Serv4Dot
	INY
	LDA (&F2),Y
	CMP #32
	BEQ Serv4Dot          \ Skip spaces
	AND #&DF
	CMP #'O'
	BNE Serv4FS       \ Not *HostFS Oxxx, select HostFS
	INY
	LDA (&F2),Y
	AND #&DF
	CMP #'N'
	BEQ HostFSOn      \ *HostFS ON
	CMP #'F'
	BEQ HostFSOff     \ *HostFS OFF
.Serv4FS
	JSR SelectFS
	PLA
	LDA #0
	RTS

\ -----------------
\ SERVICE 9 - *Help
\ -----------------
.Serv9
	LDA (&F2),Y
	CMP #13
	BNE Serv9Exit       \ Not *Help<cr>
	JSR ummOSNEWL
.Serv9a
	LDX #0
.Serv9Lp
	LDA hostfs_name,X
	BNE Serv9Chk    \ Display ROM title
	LDA #' '
	BNE Serv9Char
.Serv9Chk
	CMP #' '
	BEQ Serv9Done
.Serv9Char
	JSR ummOSWRCH
	INX
	BNE Serv9Lp
.Serv9Done
	JSR ummOSNEWL
.Serv9Exit
	LDA #9
	RTS

\ -----------------------------
\ SERVICE &0F - Vectors changed
\ -----------------------------
.ServF
	RTS

\ --------------------------------
\ SERVICE &10 - SPOOL/EXEC closing
\ --------------------------------
.Serv10
	RTS

\ --------------------------------------------
\ *HostFS ON|OFF command - connect Tube client
\ --------------------------------------------
\ NB, *HostFS ON doesn't catch errors correctly
\
.HostFSOff
	PLA
	LDA #0
	RTS
.HostFSOn
	PLA
\LDX #0\LDY #12\LDA #10    \ CLIV-RDCHV
\LDX #6\LDY #21\LDA #8     \ Just WRCHV
	 LDX #6
	LDY #21
	LDA #10    \ WRCHV-RDCHV
\LDX #8\LDY #24\LDA #10    \ Just RDCHV
	JSR SetVectors               \ Set vectors
	BEQ Serv12Serial             \ Take over Serial system
	BEQ Serv12Select             \ Select HOSTFS
	LDA &F4
	STA &190+252         \ ROM to enter on BRK
	PHA
	JMP Serv4FS

\ ----------------------------------
\ SERVICE &12 - Select filing system
\ ----------------------------------
.Serv12
	CPY Serv25Table+10
	BEQ *+3
	RTS
.Serv12Select
	LDA #6
	JSR CallFSCV          \ New filing system taking over
	LDX #10
	LDY #27
	LDA #24      \ Set FILEV-FSCV
	JSR SetVectors               \ Set vectors
	LDA #143
	LDX #15
	JSR OSBYTE  \ Vectors changed
.Serv12Serial                \ We're taking over Serial system
	LDA #156
	LDX #RxInit
	LDY #0
	JSR OSBYTE  \ Disable ACIA IRQs, raise RTS
	LDA #232
	LDX #0
	LDY #0
	JSR OSBYTE       \ Mask out all ACIA IRQs
	LDA #0
	RTS
.CallFSCV
	JMP (FSCV)

.SetVectors
	STA &A8
.SetVectorLp
	TYA
	STA CLIV+0,X             \ Vect->ExVec
	LDA #&FF
	STA CLIV+1,X
	LDA Vectors+0,X
	STA &D9F,Y   \ ExVec->MyRoutine
	LDA Vectors+1,X
	STA &DA0,Y
	LDA &F4
	STA &DA1,Y
	INY
	INY
	INY
	INX
	INX
	CPX &A8
	BNE SetVectorLp
	RTS

\ ---------------------------------------
\ SERVICE &25 - Filing system information
\ ---------------------------------------
.Serv25
	LDX #0
.Serv25Lp
	LDA Serv25Table,X
	STA (&F2),Y
	INY
	INX
	CPX #11
	BNE Serv25Lp
	LDA #&25
	RTS
.Serv25Table
	EQUS "HOSTFS  "
	EQUB chanlo
	EQUB chanhi
	EQUB myfs

\TYA\PHA\LDA #7\JSR MyosFSC
\TYA\PHA\TXA\PHA
\TSX\LDA &103,X\TAY
\PLA\STA (&F2),Y\INY
\PLA\STA (&F2),Y\INY
\LDA #myfs\STA (&F2),Y\INY
\PLA

\ ------------------
\ Filing system code
\ ------------------
.SelectFS
	LDY Serv25Table+10
	LDX #18
	LDA #143
	JMP OSBYTE

\ ----------------------------
\ I/O system routine addresses
\ ----------------------------
.Vectors
.IOVectors
	EQUW MyosCLI
	EQUW MyosBYTE
	EQUW MyosWORD
	EQUW MyosWRCH
	EQUW MyosRDCH_IO
\ Need some way of seeing that Host has not actioned
\ a CLI/BYTE/WORD and pass them on locally.

\ -------------------------------
\ Filing system routine addresses
\ -------------------------------
.FSVectors
	EQUW MyosFILE
	EQUW HostARGS
	EQUW MyosBGET
	EQUW MyosBPUT
	EQUW MyosGBPB
	EQUW HostFIND
	EQUW HostFSC

\ ------------------------------
\ Precheck ummOSARGS for local info
\ ------------------------------
\ Need to return filing system number and address of
\ command line parameters locally. Master FileSwitch
\ does this check itself, so these two calls are never
\ passed here.
\
.HostARGS
	CPY #0
	BNE TubeARGS
	CMP #1
	BCC HostARGS0
	BEQ HostARGS1
.TubeARGS
	JMP MyosARGS

\ ummOSARGS 0,0 - Return FS number
\ -----------------------------
\ Return fs=HostFS
.HostARGS0
	LDA Serv25Table+10
	RTS

\ ummOSARGS 1,0 - Return command line address
\ ----------------------------------------
.HostARGS1
	LDA CMD+0
	STA 0,X
	LDA CMD+1
	STA 1,X
	LDA #&FF
	STA 2,X
	STA 3,X
	LDA #&00
	RTS

\ ---------------------------
\ Precheck ummOSFIND for CLOSE#0
\ ---------------------------
.HostFIND
	CMP #0
	BNE TubeFind         \ Not CLOSE
	CPY #0
	BNE TubeFind         \ Not CLOSE#0
	TXA
	PHA
	LDA #&77
	JSR OSBYTE \ Close Exec and Spool files
	PLA
	TAX
	LDA #0
	TAY          \ Restore for CLOSE#0
.TubeFind
	JMP MyosFIND

\ ----------------
\ Precheck for FSC
\ ----------------
\ Need to find parameters on *commands to return
\ later with ummOSARGS 1,0. Master FileSwitch does
\ this itself, client does this within FSC.
.HostFSC
	CMP #6
	BEQ HostFSC6
	CMP #7
	BEQ HostFSC7
	CMP #8
	BEQ HostFSCQuit
	JMP MyosFSC
.HostFSC6
	LDA #156
	LDX #&56
	LDY #0
	JSR OSBYTE  \ Release the Serial system
	LDA #232
	LDX #255
	LDY #0
	JSR OSBYTE  \ Pass ACIA IRQs back to MOS
.HostFSC7
	LDX Serv25Table+8           \ Lowest handle
	LDY Serv25Table+9           \ Highest handle
.HostFSCQuit
	RTS

\ -----------------------------
\ Generate a sideways ROM error
\ -----------------------------
.Error
	PLA
	STA FAULT+0
	PLA
	STA FAULT+1
	LDY #0
	STY ERRBUF
	INY
	LDA (FAULT),Y
	STA ERRBUF,Y
.ErrorLp
	INY
	LDA (FAULT),Y
	STA ERRBUF,Y
	BNE ErrorLp
	JMP ERRBUF

\ ----------
\ Debug code
\ ----------
.PrStack
	PHP
	PHA
	TXA
	PHA
	TSX
	LDA &106,X
	JSR PrHex
	LDA &107,X
	JSR PrHex
	LDA &108,X
	JSR PrHex
	LDA &109,X
	JSR PrHex
	LDA &10A,X
	JSR PrHex
	LDA &10B,X
	JSR PrHex
	LDA &10C,X
	JSR PrHex
	LDA &10D,X
	JSR PrHex
	LDA &10E,X
	JSR PrHex
	LDA &10F,X
	JSR PrHex
	PLA
	TAX
	PLA
	PLP
	RTS

	IF NOT SWROM
\ Start of Tube system code
\ =========================
\ On hardware reset all of memory reads come from ROM, all writes go to RAM.
\ Accessing any I/O location pages ROM out of memory map, thence all reads
\ come from RAM.
\
.LF800
	JMP RESET
.PrBanner
	JSR PrText
.BANNER
	EQUB 13
	EQUS "SERIAL TUBE 6502 64K "
	EQUS LEFT$(ver$+" ",5)
	EQUB 13
	EQUB 0
	RTS

\ Tube Client Startup Code
\ ========================
.RESET
	SEI
	LDX #&00               \ Disable interupts
.LF802
	LDA &FF00,X
	STA &FF00,X    \ Copy entry block to RAM
	DEX
	BNE LF802

\ The following code copies the page with the I/O registers in
\ it without accessing the I/O registers. Modify IOSPACE% according
\ to where the I/O registers actually are.

	LDX #IOSPACE% AND 255
.LF819
	LDA &FDFF,X
	STA &FDFF,X    \ Copy &FE00-&FEEF to RAM, avoiding
	DEX
	BNE LF819              \  IO space at &FEFx

	LDY #ROMSTART% AND 255
	STY LPTR+0 \ Point to start of ROM
	LDA #ROMSTART% DIV 256
	STA LPTR+1
.LF82A                     \ Copy rest of ROM to RAM
	LDA (LPTR),Y
	STA (LPTR),Y  \ Copy a page to RAM
	INY
	BNE LF82A              \ Loop for 256 bytes
	INC LPTR+1
	LDA LPTR+1      \ Inc. address high byte
	CMP #&FE
	BNE LF82A         \ Loop up to &FDFF

.STARTUP
	SEI
	LDX #&35
.LF80D
	LDA LFF00,X
	STA USERV,X    \ Set up default vectors
	DEX
	BPL LF80D
	TXS          \  and clear stack
	LDA TxInit
	STA TxStatus    \ Initialise port and page ROM out
	LDA RxInit
	STA RxStatus
	                           \ Accessing I/O registers will page ROM out if running
	                           \ from RAM. Once ROM is paged out we can do subroutine
	                           \ calls as we can now read from stack in RAM.

	LDA #&00
	STA ESCFLG
	STA MEMTOP+0    \ Clear Escape flag
	LDA #ROMSTART% DIV 256
	STA MEMTOP+1 \ Set memtop to start of ROM
	JSR InitError                       \ Claim error handler
	LDA PROG+0
	STA TRANS+0              \ Copy PROG to TRANS address
	LDA PROG+1
	STA TRANS+1

\ Tell the Host that we've restarted
\ ----------------------------------
\ Tube data  &18 &00 &FF &FF  --  Cy Y X
\            followed by string
\
\ Note for Host authors, Host MUST NOT respond by echoing back a SoftReset
\ as the Client will be trapped in an infinite STARTUP loop. If Host wants
\ to read Client to determine CPU this will change TRANS so must only be
\ done if a later transaction will set TRANS after a language transfer, eg
\ on Hard Reset.
\
	LDX #0
	LDA #&FF
	TAY
	JSR MyosFSC \ As we are using a serial link, send a Soft Reset
	TXA
.STARTUP2
	PHA                        \ Save returned Ack byte, will be &00 if no response
	JSR PrBanner
	JSR ummOSNEWL    \ Display startup banner
	LDA #CmdPrompt AND 255     \ Next time RESET is soft entered,
	STA LF800+1                \  banner not printed
	LDA #CmdPrompt DIV 256
	STA LF800+2
	PLA
	CLC
	JSR WaitCheckCode  \ Check Ack code, if &80 enter code,
	\  else enter command prompt loop


\ Supervisor Command prompt
\ =========================
.CmdPrompt
	LDX #&FF
	TXS
	JSR InitError        \ Reset stack, claim error handler
	LDA #CmdPrompt AND 255
	STA PROG+0 \ Make Command Prompt the current program
	LDA #CmdPrompt DIV 256
	STA PROG+1
.CmdOSLoop
	LDA #'*'
	JSR ummOSWRCH     \ Print '*' prompt
	LDX #LF95D AND 255
	LDY #LF95D DIV 256
	LDA #&00
	JSR ummOSWORD        \ Read line to INPBUF
	BCS CmdOSEscape
	LDX #INPBUF AND 255
	LDY #INPBUF DIV 256        \ Execute command
	JSR ummOS_CLI
	JMP CmdOSLoop   \  and loop back for another
.CmdOSEscape
	LDA #&7E
	JSR OSBYTE        \ Acknowledge Escape state
	M_ERROR
	EQUB 17
	EQUS "Escape"
	BRK

\ Control block for command prompt input
\ --------------------------------------
.LF95D
	EQUW INPBUF                \ Input text to INPBUF at &236
	EQUB INPEND-INPBUF         \ Up to &CA characters
	EQUB &20
	EQUB &FF          \ Min=&20, Max=&FF


\ Error handler
\ =============
.InitError
	LDA #ErrorHandler AND 255
	STA BRKV+0 \ Claim error handler
	LDA #ErrorHandler DIV 256
	STA BRKV+1
	RTS

.ErrorHandler
	LDX #&FF
	TXS               \ Reset stack
	JSR ummOSNEWL
	LDX FAULT+0
	LDY FAULT+1
	INX
	BNE *+3
	INY           \ XY=>error string
	JSR PRSTRNG                \ Print error string
	JSR ummOSNEWL
	JMP CmdPrompt   \ Jump to command prompt


\ Interrupt handlers
\ ==================
.IRQHandler
	STA IRQA
	PLA
	PHA           \ Save A, get flags from stack
	AND #&10
	BNE BRKHandler    \ If BRK, jump to BRK handler
	JMP (IRQ1V)                \ Continue via IRQ1V handler
.IRQ1Handler
	JMP (IRQ2V)                \ Pass on to IRQ2V
.BRKHandler
	TXA
	PHA                    \ Save X
	TSX
	LDA &0103,X            \ Get address from stack
	CLD
	SEC
	SBC #&01
	STA FAULT+0
	LDA &0104,X
	SBC #&00
	STA FAULT+1       \ &FD/E=>after BRK opcode
	PLA
	TAX
	LDA IRQA           \ Restore X, get saved A
	CLI
	JMP (BRKV)             \ Restore IRQs, jump to Error Handler
.IRQ2Handler
	LDA IRQA                   \ Restore saved A
.NMIHandler
	RTI


\ Skip Spaces
\ ===========
.SkipSpaces1
	INY
.SkipSpaces
	LDA (LPTR),Y
	CMP #&20
	BEQ SkipSpaces1
.NullReturn
	RTS

\ Scan hex
\ ========
.ScanHex
	LDX #&00
	STX NUM+0
	STX NUM+1 \ Clear hex accumulator
.LF98C
	LDA (LPTR),Y                \ Get current character
	CMP #&30
	BCC LF9B1          \ <'0', exit
	CMP #&3A
	BCC LF9A0          \ '0'..'9', add to accumulator
	AND #&DF
	SBC #&07
	BCC LF9B1 \ Convert letter, if <'A', exit
	CMP #&40
	BCS LF9B1          \ >'F', exit
.LF9A0
	ASL A
	ASL A
	ASL A
	ASL A     \ *16
	LDX #&03                    \ Prepare to move 3+1 bits
.LF9A6
	ASL A
	ROL NUM+0
	ROL NUM+1   \ Move bits into accumulator
	DEX
	BPL LF9A6               \ Loop for four bits, no overflow check
	INY
	BNE LF98C               \ Move to next character
.LF9B1
	RTS


\ MOS INTERFACE
\ ~~~~~~~~~~~~~
\
\
\ OSRDCH - Wait for character from input stream
\ =============================================
\ On exit, A =char, Cy=Escape flag
\
.MyosRDCH
	JSR WaitByte
	PHA           \ Wait for character
	LDA ESCFLG
	ASL A           \ Get Escape flag to carry
	PLA
	RTS                    \ Get character to A and return


\ OSRDCH - Request character via Tube
\ ===================================
\ On exit, A =char, Cy=Escape flag
\
\ Tube data  &00  --  Carry Char
\
.MyosRDCH_IO
	LDA #&00
	JSR SendCommand   \ Send command &00 - OSRDCH
.WaitCarryChar             \ Wait for Carry and A
	JSR WaitByte
	ASL A         \ Wait for carry
	JMP WaitByte


\ OSCLI - Execute command
\ =======================
\ On entry, XY=>command string
\ On exit,  All registers corrupted

\ Local *commands
\ ---------------
.CmdTable
	EQUS "GO"
	EQUB &80
	EQUS "HELP"
	EQUB &81
	EQUB 0

.MyosCLI
	STX LPTR+0
	STY LPTR+1      \ LPTR=>command string
	LDY #&00
.LF9D1
	JSR SkipSpaces
	INY
	CMP #'*'
	BEQ LF9D1      \ Skip spaces and stars
	CMP #'A'
	BCS osCLI_IO   \ Doesn't start with a letter
	DEY
	TYA
	PHA                \ Save start of command line
	LDX #&FF
.osCLIlp2
	INX
	INY                    \ Step to next characters
	LDA (&F2),Y
	CMP #'.'
	BEQ osCLIdot   \ Abbreviated command
	AND #&DF
	CMP CmdTable,X
	BEQ osCLIlp2               \ Check next character
	LDA CmdTable,X
	BMI osCLImatch
	BPL osCLIskip              \ Not full command, skip
.osCLIdot
	LDA CmdTable,X
	BPL osCLInext \ Dot not at end of full command
.osCLIskip
	DEX
	CLC
.osCLInext
	INX
.osCLIdot
	LDA CmdTable,X
	BPL osCLInext  \ Step to end of entry
	BCS osCLIfound
	PLA
	PHA
	TAY                   \ Restore line pointer
	LDA CmdTable+1,X
	BNE osCLIlp2 \ Not at end of table
	PLA
	JMP osCLI_IO              \ Pass to Tube
.osCLImatch
	LDA (LPTR),Y
	CMP #'A'
	BCS osCLInext    \ More letters, check next entry
.osCLIfound
	PLA
	JSR SkipSpaces         \ Drop saved offset, skip spaces
	LDA CmdTable,X             \ Get command byte
	CMP #&81
	BEQ CmdHelp       \ &81, jump to *Help
	                           \ Fall through to *Go

\ *GO - call machine code
\ -----------------------
.CmdGo
	JSR ScanHex
	JSR SkipSpaces   \ Read hex value and move past spaces
	CMP #&0D
	BNE osCLI_IO        \ More parameters, pass to Tube to deal with
	TXA
	BEQ CmdGo2
	LDX #NUM-PROG \ If no parameters, jump to PROG, else jump to NUM
.CmdGo2
	LDA PROG+0,X
	STA TRANS+0   \ Set address to jump to
	LDA PROG+1,X
	STA TRANS+1
	BCS SaveEnterCode          \ CS set from CMP earlier

\ *Help - Display help information
\ --------------------------------
.CmdHelp
	JSR PrBanner               \ Print help message
	                           \ Continue to pass '*Help' command to Tube

\ OSCLI - Send command line to host
\ =================================
\ On entry, &F8/9=>command string
\
\ Tube data  &02 string &0D  --  &7F or &80
\
.osCLI_IO
	LDA #&02
	JSR SendCommand   \ Send command &02 - OSCLI
	JSR SendStringF8           \ Send command string at LPTR
	\ Drop through to wait for Ack and enter code

.WaitEnterCode
	JSR WaitByte
	SEC           \ Wait for Ack from Tube
.WaitCheckCode
	ROL A
	BCC SaveEnterDone    \ If <&80, exit
	ROR A                      \ Restore Carry, CC=RESET, CS=OSCLI
.SaveEnterCode
	LDA PROG+1
	PHA
	LDA PROG+0
	PHA \ Save current program
	JSR EnterCode
	TAX             \ Enter code, save return value
	PLA
	STA PROG+0
	STA MEMTOP+0   \ Restore current program 
	PLA
	STA PROG+1
	STA MEMTOP+1   \  and set top of memory to it
	TXA                           \ A=return value
.SaveEnterDone
	RTS


\ FSC - FSC Functions
\ ===================
\ On entry, A, X, Y=FSC parameters
\ On exit,  A, X, Y=return values
\
\ Tube data  &18 X Y A  --  &FF Y X or
\                           &7F then string -- respsonse
\
.MyosFSC
	PHA
	LDA #&18
	SEC
	BCS ByteHi2


\ OSBYTE - Byte MOS functions
\ ===========================
\ On entry, A, X, Y=OSBYTE parameters
\ On exit,  A  preserved
\           If A<&80, X=returned value
\           If A>&7F, X, Y, Carry=returned values
\
.MyosBYTE
	CMP #&80
	BCS ByteHigh      \ Jump for long OSBYTEs
\
\ BYTELO
\ Tube data  &04 X A    --  X
\
	PHA
	LDA #&04
	JSR SendCommand  \ Send command &04 - BYTELO
	TXA
	JSR SendByte           \ Send single parameter
	PLA
	PHA
	JSR SendByte       \ Send function
	JSR WaitByte
	TAX           \ Get return value
	PLA
	RTS                    \ Restore A and return

.ByteHigh
	CMP #&82
	BEQ Byte82        \ Read memory high word
	CMP #&83
	BEQ Byte83        \ Read bottom of memory
	CMP #&84
	BEQ Byte84        \ Read top of memory
\
\ BYTEHI
\ Tube data  &06 X Y A  --  Cy Y X
\
	PHA
	LDA #&06
	CLC
.ByteHi2
	PHP
	JSR SendCommand
	PLP    \ Send command &06 or &18 - BYTEHI or FSC
	TXA
	JSR SendByte           \ Send first parameter
	TYA
	JSR SendByte           \ Send second parameter
	PLA
	JSR SendByte           \ Send function
	BCS ByteHi3                \ Skip OSBYTE checks
	CMP #&8E
	BEQ WaitEnterCode \ If select language, check to enter code
	CMP #&9D
	BEQ LFAEF
	CLC     \ Fast return with Fast BPUT
.ByteHi3
	PHA
	JSR WaitByte
	BCC ByteHi4 \ Get Carry or byte/string response
	ASL A
	BCC FSCString          \ Jump to send FSC string
.ByteHi4
	ASL A
	JSR WaitByte
	TAY     \ Get return high byte
	JSR WaitByte
	TAX
	PLA       \ Get return low byte
.LFAEF
	RTS

.Byte84
	LDX MEMTOP+0
	LDY MEMTOP+1
	RTS \ Read top of memory
.Byte83
	LDX #&00
	LDY #&08
	RTS  \ Read bottom of memory
.Byte82
	LDX #&00
	LDY #&00
	RTS  \ Return &0000 as memory high word

.FSCString
	PLA
	JSR SendString         \ Send string
	LDY #&FF
.FSCStrLp2
	INY
	LDA (LPTR),Y
	CMP #'!'
	BCS FSCStrLp2  \ Skip to ' ' or <cr>
	DEY
.FSCStrLp3
	INY
	LDA (LPTR),Y
	CMP #' '
	BEQ FSCStrLp3  \ Skip to non-' '
	TYA
	CLC
	ADC LPTR+0
	STA CMD+0
	LDA LPTR+1
	ADC #0
	STA CMD+1
	JSR WaitEnterCode          \ Wait for Ack, enter code if needed
	BPL LFAEF                  \ Response=<&40, all done, return response
	\ Response=&40 (&80 at this point), print text
.FSCStrChr
	JSR WaitByte               \ Wait for a character
	CMP #&00
	BEQ LFAEF         \ &00 terminates string
	JSR OSWRCH
	JMP FSCStrChr   \ Print character


\ OSWORD - Various functions
\ ==========================
\ On entry, A =function
\           XY=>control block
\
.MyosWORD
	STX LPTR+0
	STY LPTR+1      \ LPTR=>control block
	TAY
	BEQ RDLINE             \ OSWORD 0, jump to read line
\
\ Tube data  &08 A in_length block out_length  --  block
\
	PHA
	PHA                    \ Save function
	LDA #&08
	JSR SendCommand   \ Send command &08 - OSWORD
	PLA
	JSR SendByte           \ Send function
	TAX
	BPL WordSendLow        \ Jump with functions<&80
	LDY #&00
	LDA (LPTR),Y      \ Get send block length from control block
	TAY
	JMP WordSend           \ Jump to send control block

.WordSendLow
	LDY WordLengthsTx-1,X      \ Get send block length from table
	CPX #&15
	BCC WordSend      \ Use this length for OSWORD 1 to &14
	LDY #&10                   \ Send 16 bytes for OSWORD &15 to &7F
.WordSend
	TYA
	JSR SendByte           \ Send send block length
	DEY
	BMI LFB45              \ Zero or &81..&FF length, nothing to send
.LFB38
	LDA (LPTR),Y
	JSR SendByte  \ Send byte from control block
	DEY
	BPL LFB38              \ Loop for number to be sent
.LFB45
	TXA
	BPL WordRecvLow        \ Jump with functions<&80
	LDY #&01
	LDA (LPTR),Y      \ Get receive block length from control block
	TAY
	JMP WordRecv           \ Jump to receive control block

.WordRecvLow
	LDY WordLengthsRx-1,X      \ Get receive length from table
	CPX #&15
	BCC WordRecv      \ Use this length for OSWORD 1 to &14
	LDY #&10                   \ Receive 16 bytes for OSWORD &15 to &7F
.WordRecv
	TYA
	JSR SendByte           \ Send receive block length
	DEY
	BMI LFB71              \ Zero of &81..&FF length, nothing to receive
.LFB64
	JSR WaitByte
	STA (LPTR),Y  \ Get byte to control block
	DEY
	BPL LFB64              \ Loop for number to receive
.LFB71
	LDY LPTR+1
	LDX LPTR+0
	PLA  \ Restore registers
	RTS


\ RDLINE - Read a line of text
\ ============================
\ On entry, A =0
\           XY=>control block
\ On exit,  A =undefined
\           Y =length of returned string
\           Cy=0 ok, Cy=1 Escape
\
\ Tube data  &0A block  --  &FF or &7F string &0D
\
.RDLINE
	OPT FNif(RDLINE%)          \ Perform RDLINE locally
	LDY #2
	LDA (LPTR),Y
	STA LPTR+2    \ Copy control block to w/s
	DEY
	LDA (LPTR),Y
	TAX
	DEY
	LDA (LPTR),Y
	STA LPTR+0
	STX LPTR+1      \ (LPTR)=>string buffer, LPTR+2=max length
.Word00Lp1
	JSR ummOSRDCH
	BCS Word00Esc   \ Wait for character
	CMP #&7F
	BNE Word00Char    \ Not Delete
.Word00Delete
	TYA
	BEQ Word00Lp1          \ Nothing to delete
	LDA #&7F
	JSR ummOSWRCH        \ VDU 127
	DEY
	JMP Word00Lp1          \ Dec. counter, loop back
.Word00Char
	CMP #&08
	BEQ Word00Delete  \ BS is also Delete
	CMP #&15
	BNE Word00Ins     \ Not Ctrl-U
	TYA
	BEQ Word00Lp1          \ Nothing to delete
	LDA #&7F
.Word00Lp2
	JSR ummOSWRCH
	DEY             \ Delete characters
	BNE Word00Lp2
	BEQ Word00Lp1              \ Jump back to start
.Word00Ins
	STA (LPTR),Y               \ Store character
	CMP #&0D
	CLC
	BEQ Word00cr  \ Return - finish
	CPY LPTR+2
	BCS Word00max   \ Maximum length
	CMP #&20
	BCS Word00ctrl    \ Control character
	DEY                        \ Cancel following INY
.Word00ctrl
	INY
	JSR ummOSWRCH             \ Inc. counter, print character
.Word00max
	JMP Word00Lp1              \ Loop for more
.Word00cr
	JSR ummOSNEWL
	CLC             \ Return with CC, Y=length
.Word00Esc
	RTS
	OPT FNelse
	LDA #&0A
	JSR SendCommand   \ Send command &0A - RDLINE
	LDY #&04
.LFB7E
	LDA (LPTR),Y
	JSR SendByte  \ Send control block
	DEY
	CPY #&01
	BNE LFB7E     \ Loop for 4, 3, 2
	LDA #&07
	JSR SendByte      \ Send &07 as address high byte
	LDA (LPTR),Y
	PHA           \ Get text buffer address high byte
	DEY
	TYA
	JSR SendByte       \ Send &00 as address low byte
	LDA (LPTR),Y
	PHA           \ Get text buffer address low byte
	LDX #&FF
	JSR WaitByte      \ Wait for response
	ASL A
	BCS RdLineEscape     \ Jump if Escape returned
	PLA
	STA LPTR+0
	PLA
	STA LPTR+1
	LDY #&00        \ Set &F8/9=>text buffer
.RdLineLp
	JSR WaitByte
	STA (LPTR),Y  \ Store returned character
	INY
	CMP #&0D
	BNE RdLineLp  \ Loop until <cr>
	LDA #&00
	DEY
	CLC
	INX       \ Return A=0, Y=len, X=00, Cy=0
	RTS
.RdLineEscape
	PLA
	PLA
	LDA #&00           \ Return A=0, Y=len, X=FF, Cy=1
	RTS
	OPT FNendif

\ ummOSWORD control block lengths
\ ----------------------------
.WordLengthsTx
	EQUB &00
	EQUB &05
	EQUB &00
	EQUB &05
	EQUB &04
	EQUB &05
	EQUB &08
	EQUB &0E
	EQUB &04
	EQUB &01
	EQUB &01
	EQUB &05
	EQUB &00
	EQUB &08
	EQUB &20
	EQUB &10
	EQUB &0D
	EQUB &00
	EQUB &04
	EQUB &80
.WordLengthsRx
	EQUB &05
	EQUB &00
	EQUB &05
	EQUB &00
	EQUB &05
	EQUB &00
	EQUB &00
	EQUB &00
	EQUB &05
	EQUB &09
	EQUB &05
	EQUB &00
	EQUB &08
	EQUB &19
	EQUB &00
	EQUB &01
	EQUB &0D
	EQUB &80
	EQUB &04
	EQUB &80


\ ummOSARGS - Read info on open file
\ ===============================
\ On entry, A =function
\           X =>data word in zero page
\           Y =handle
\ On exit,  A =returned value
\           X  preserved
\           Y  preserved
\
\ Tube data  &0C handle block function  --  result block
\
.MyosARGS
	PHA
	LDA #&0C
	JSR SendCommand \ Send command &0C - ummOSARGS
	TYA
	JSR SendByte           \ Send handle
	LDA &03,X
	JSR SendByte     \ Send data word
	LDA &02,X
	JSR SendByte
	LDA &01,X
	JSR SendByte
	LDA &00,X
	JSR SendByte
	PLA
	JSR SendByte           \ Send function
	JSR WaitByte
	PHA           \ Get and save result
	JSR WaitByte
	STA &03,X     \ Receive data word
	JSR WaitByte
	STA &02,X
	JSR WaitByte
	STA &01,X
	JSR WaitByte
	STA &00,X
	PLA
	RTS                    \ Get result back and return


\ ummOSBGET - Get a byte from open file
\ ==================================
\ On entry, Y =handle
\ On exit,  A =byte Read
\           Y =preserved
\           Cy set if EOF
\
\ Tube data  &0E handle --  Carry byte
\
.MyosBGET
	LDA #&0E
	JSR SendCommand   \ Send command &0E - ummOSBGET
	TYA
	JSR SendByte           \ Send handle
	JMP WaitCarryChar          \ Jump to wait for Carry and byte


\ ummOSBPUT - Put a byte to an open file
\ ===================================
\ On entry, A =byte to write
\           Y =handle
\ On exit,  A =preserved
\           Y =preserved
\
\ Tube data  &10 handle byte  --  &7F
\
.MyosBPUT
	PHA
	LDA #&10
	JSR SendCommand \ Send command &10 - ummOSBPUT
	TYA
	JSR SendByte           \ Send handle
	PLA
	JSR SendByte           \ Send byte
	PHA
	JSR WaitByte
	PLA
	RTS   \ Wait for acknowledge and return


\ ummOSFIND - Open or Close a file
\ =============================
\ On entry, A =function
\           Y =handle or XY=>filename
\ On exit,  A =zero or handle
\
\ Tube data  &12 function string &0D  --  handle
\            &12 &00 handle  --  &7F
\
.MyosFIND
	PHA
	LDA #&12
	JSR SendCommand \ Send command &12 - ummOSFIND
	PLA
	JSR SendByte           \ Send function
	CMP #&00
	BNE OPEN          \ If <>0, jump to do OPEN
\ CLOSE
	PHA
	TYA
	JSR SendByte       \ Send handle
	JSR WaitByte
	PLA
	RTS       \ Wait for acknowledge, restore regs and return
.OPEN
	JSR SendString             \ Send pathname
	JMP WaitByte               \ Wait for and return handle


\ ummOSFILE - Operate on whole files
\ ===============================
\ On entry, A =function
\           XY=>control block
\ On exit,  A =result
\           control block updated
\
\ Tube data  &14 block string <cr> function  --  result block
\
.MyosFILE
	STX CTRL+0
	STY CTRL+1        \ CTRL=>control block
	PHA
	LDA #&14
	JSR SendCommand \ Send command &14 - ummOSFILE
	LDY #&11
.LFC5F
	LDA (CTRL),Y
	JSR SendByte  \ Send control block
	DEY
	CPY #&01
	BNE LFC5F     \ Loop for &11..&02
	DEY
	LDA (CTRL),Y
	TAX
	INY
	LDA (CTRL),Y
	TAY       \ Get pathname address to XY
	JSR SendString             \ Send pathname
	PLA
	JSR SendByte           \ Send function
	JSR WaitByte
	PHA           \ Wait for result
	LDY #&11
.LFC7E
	JSR WaitByte
	STA (CTRL),Y  \ Get control block back
	DEY
	CPY #&01
	BNE LFC7E     \ Loop for &11..&02
	LDY CTRL+1
	LDX CTRL+0      \ Restore registers
	PLA
	RTS                    \ Get result and return


\ ummOSGBPB - Multiple byte Read and write
\ =====================================
\ On entry, A =function
\           XY=>control block
\ On exit,  A =returned value
\              control block updated
\
\ Tube data  &16 block function  --   block Carry result
\
.MyosGBPB
	STX CTRL+0
	STY CTRL+1        \ CTRL=>control block
	PHA
	LDA #&16
	JSR SendCommand \ Send command &16 - ummOSGBPB
	LDY #&0C
.LFC9A
	LDA (CTRL),Y
	JSR SendByte  \ Send control block
	DEY
	BPL LFC9A              \ Loop for &0C..&00
	PLA
	JSR SendByte           \ Send function
	LDY #&0C
.LFCA8
	JSR WaitByte
	STA (CTRL),Y  \ Get control block back
	DEY
	BPL LFCA8              \ Loop for &0C..&00
	LDY CTRL+1
	LDX CTRL+0      \ Restore registers
	JMP WaitCarryChar          \ Jump to get Carry and result


\ Tube I/O routines
\ =================

\ Send a string
\ -------------
.SendString
	STX LPTR+0
	STY LPTR+1      \ Set LPTR=>string
.SendStringF8
	LDY #&00
.LF9B8
	LDA (LPTR),Y
	JSR SendByte  \ Send character to I/O
	INY
	CMP #&0D
	BNE LF9B8     \ Loop until <cr> sent
	LDY LPTR+1
	RTS             \ Restore Y from &F9 and return


\ ummOSWRCH - Send character to output stream
\ ========================================
\ On entry, A =character
\ On exit,  A =preserved
\
\ Tube data  character  --
\
.MyosWRCH                    \ WRCH is simply SendByte


\ Tube Core I/O Routines
\ ======================
\ Characters and commands are sent over the same single port
\ Outward commands are escaped, and inward responses are escaped
\
\ Outward
\   x                 VDU x
\   esc,esc           VDU esc
\   esc,n             MOS function, control block follows
\
\ Inward
\   x                 char/byte x
\   esc,esc           char/byte esc
\   esc,&00           BRK, error number+text+null follows
\   esc,<&80          read returned control block set length
\   esc,&8n           Escape change, b0=new state
\   esc,&9x,Y,X,A     Event
\   esc,&Ax           reserved for networking
\   esc,&Bx           end transfer
\   esc,&Cx,addr      set address
\   esc,&Dx,addr      execute address
\   esc,&Ex,addr      start load from address
\   esc,&Fx,addr      start save from address
\   All commands are data inward, except esc,&Fx which is data outward


\ Send a byte, escaping it if needed
\ ----------------------------------
\ On entry, A=byte to send
\ On exit,  A,P preserved
\
.SendByte
	PHP
	JSR SendData           \ Send byte
	CMP #esc
	BNE SendByte2     \ If not esc, done
	JSR SendData               \ If esc, send twice to prefix it
.SendByte2
	PLP
	RTS

\ Send an escaped command
\ -----------------------
\ On entry, A=command
\ On exit,  A,X,Y preserved, P corrupted
.SendCommand
	PHA
.SendCmdLp
	JSR ReadByte
	BCS SendCmdLp \ Flush input
	LDA #esc
	JSR SendData      \ Send esc prefix
	PLA
	JMP SendData           \ Send command byte (always <&80)

\ Check if a byte is waiting, and read it if there
\ ------------------------------------------------
\ On exit, P=EQ CC - nothing waiting
\          P=NE CS - byte waiting, returned in A
\
.ReadByte
	JSR ReadData               \ See if data present
	PHP
	BCS WaitByte2          \ Data present, continue with it
	PLP
	LDA #0
	RTS             \ No data present

\ Wait for a byte, decoding escaped data
\ --------------------------------------
\ On exit, A =byte
\          P =preserved
\
.WaitByte
	PHP
.WaitByteLp
	JSR WaitData               \ Wait for data present
.WaitByte2
	BNE WaitByteOk             \ Not esc, return it
	JSR WaitData
	BEQ WaitByteOk\ esc,esc, return as esc
	PHA
	TYA
	PHA
	TXA
	PHA
	TSX    \ Save registers
	LDA &103,X
	JSR WaitCommand \ Decode escaped command
	PLA
	TAX
	PLA
	TAY
	PLA        \ Restore registers
	JMP WaitByteLp             \ Loop back to wait for a byte
.WaitByteOk
	PLP                        \ Restore flags
.WaitByteOk2
	RTS                        \ Return byte

\ Wait for raw byte of data
\ -------------------------
\ On exit, A =byte
\          P =EQ byte=esc, NE byte<>esc
\
.WaitData
	JSR ReadData
	BCC WaitData  \ Loop until data present
	RTS

\ Decode escaped command
\ ----------------------
\ On entry, A=command, P set accordingly
\ All registers can be trashed
\
.WaitCommand
	BEQ WaitError              \ esc,&00 - error
	BMI WaitTransfer           \ esc,>&7F - data transfer

\ esc,1..127 - read a control block
\ ---------------------------------
	TAY                        \ Move count to Y
.WaitLength
	JSR WaitByte               \ Wait for a byte
	DEY
	STA (CTRL),Y           \ Store it
	BPL WaitLength
	RTS

\ esc,&00 - error
\ ---------------
.WaitError
	STA ERRBUF
	TAY             \ Store error BRK
	JSR WaitByte
	STA ERRBUF+1  \ Store error number
.WaitErrorLp
	JSR WaitByte
	STA ERRBUF+2,Y\ Store error character
	INY
	CMP #0
	BNE WaitErrorLp \ Loop until final &00

\\ This doesn't work
\\ .WaitErr1
\\ LDA #&1E\JSR SendCommand   \ Send a SYNC command
\\ JSR ReadByte\BCC WaitErr1  \ Wait until Host responds
\\ .WaitErr2
\\ JSR ReadByte\BCS WaitErr2  \ Flush everything from host

	LDX #16
	TAY
.WaitErr1
	DEY
	BNE WaitErr1           \ Pause a while to let Host
	DEX
	BNE WaitErr1           \  reconnect after an error

	JSR WaitExitRelease        \ Release Tube, restore Screen
	LDA ERRBUF+1
	ORA ERRBUF+2  \ Check for error 0,""
	BEQ *+5
	JMP ERRBUF        \ Jump to error, no return
	JMP STARTUP2               \ Error 0,"" is RESET

\ esc,&8n - Escape change
\ -----------------------
.WaitTransfer
	CMP #&C0
	BCS WaitStart
	CMP #&A0
	BCS WaitEnd
	CMP #&90
	BCS WaitEvent
	LSR A
	ROR ESCFLG
	RTS       \ Set error flag from b0

\ esc,&9x - Event
\ ---------------
.WaitEvent
	JSR WaitByte
	TAY           \ Fetch event Y parameter
	JSR WaitByte
	TAX           \ Fetch event X parameter
	JSR WaitByte               \ Fetch event A parameter
	JMP (EVNTV)                \ Dispatch to event vector

\ esc,&Ax - Reserved
\ ------------------
.WaitEnd
	CMP #&B0
	BCC WaitExit      \ Return to WaitByte

\ esc,&Bx - End transfer
\ ----------------------
	PLA
	PLA
	PLA
	PLA
	PLA
	PLA    \ Pop JSR WaitCommand, A,Y,X,A
	PLA
	PLA                    \ Pop JSR Wait/ReadByte in Load/SaveLoop
.WaitExitSave
	PLA
	BPL WaitExitRelease    \ Pop transfer flag, b0=0 - Tube release
	ROR A
	BCS WaitExitScreen   \ b0=1, Screen release
.WaitExit
	RTS
.WaitExitRelease
	OPT FNif(SWROM%)
	  JSR TubeRelChk           \ Release if Tube present
	OPT FNendif
.WaitExitScreen
	OPT FNif(SWROM%)
	  LDY #0
	JMP vramSelect    \ Page in main memory, return to WaitByte
	OPT FNelse
	  RTS
	OPT FNendif

\ esc,&C0+ - Start transfer
\ -------------------------
.WaitStart
	PHA
	LDY #4                 \ Save command, point to TRANS
.WaitStartLp
	JSR WaitByte
	STA TRANS-1,Y \ Wait for 4-byte data address
	DEY
	BNE WaitStartLp
	PLA
	CMP #&D0
	BCC WaitExit  \ esc,&Cx - set address for later entry
	CMP #&E0
	BCC CallCode      \ esc,&Dx - enter code immediately

\ Decide what local memory to transfer data to/from
\ -------------------------------------------------
\ A=&Ex/&Fx - Load/Save
\
	OPT FNif(SWROM%)
	  LDX &27A
	BPL WaitTransIO \ No Tube
	  LDX TRANS+3              \ Check transfer address
	  INX
	BNE WaitTransTube    \ Tube present, ADDR<&FFxxxxxx
	OPT FNendif
.WaitTransIO
	AND #&F0                   \ A=transfer flag with b7=1 for IO transfer
	OPT FNif(SWROM%)
	  TAY
	  LDX TRANS+2
	INX
	BEQ WaitIOGo \ &FFFFxxxx - current IO memory
	  LDA &D0
	INX
	BEQ WaitIOScreen \ &FFFExxxx - current display memory
	  INX
	BNE WaitIOGo
	LDA #16     \ &FFFDxxxx - shadow screen memory
	  .WaitIOScreen
	  AND #16
	BEQ WaitIOGo         \ Non-shadow screen displayed, jump with Y=&E0/&F0
	  INY
	JSR vramSelect           \ Page in video RAM, Y is now &E1/&F1
	  .WaitIOGo
	  TYA
	OPT FNendif
	PHA
	LDY #0                 \ Stack IO/Screen flag, init Y=0
	CMP #&F0
	BCS WaitSaveIO    \ esc,&Fx - save data

\ Load data from remote host
\ --------------------------
.WaitLoadIO
	JSR WaitByte
	STA (TRANS),Y \ esc,&Ex - load data
	INY
	BNE WaitLoadIO
	INC TRANS+1
	JMP WaitLoadIO \ Loop until terminated by esc,&Bx

\ Save data to remote host
\ ------------------------
.WaitSaveIO
	LDA (TRANS),Y
	JSR SendByte     \ esc,&Fx - save data
	JSR ReadByte
	BCS WaitSaveExit  \ Poll input for termination
	INY
	BNE WaitSaveIO             \ Update checksum for 256 bytes
	INC TRANS+1
	JMP WaitSaveIO     \ Loop until terminated by esc,&Bx
.WaitSaveExit
	JMP WaitExitSave

\ Tube and ADDR<&FFxxxxxx
\ -----------------------
	OPT FNif(SWROM%)
	  .WaitTransTube
	  CLC
	ADC #&10
	ROL A       \ Cy=1/0 for load/save
	  LDA #0
	ADC #0
	PHA        \ A=1/0 for load/save
	  JSR TubeAction           \ Claim Tube and start transfer
	  PLA
	PHA
	BEQ WaitSaveTube \ Leave flag pushed with b7=0 for Tube transfer
	  .WaitLoadTube
	  JSR TubeDelay
	  JSR WaitByte
	STA &FEE5   \ Fetch byte and send to Tube
	  JMP WaitLoadTube         \ Loop until terminated by esc,&Bx
	  .WaitSaveTube
	  LDA &FEE5
	JSR SendByte         \ Fetch byte from Tube and send it
	  JSR ReadByte
	BCS WaitSaveExit  \ Poll input for termination
	  JSR TubeDelay
	  JMP WaitSaveTube               \ Loop until terminated by esc,&Bx
	OPT FNendif

\ Enter code
\ ----------
.CallCode
	LDA #&00
	SEC
	JMP (TRANS)   \ Enter code with A=0, SEC


\ Screen selection routines
\ =========================
	OPT FNif(SWROM%)
	  .vramSelect
	  TYA
	PHA
	AND #1
	PHA
	TAX   \ A=0 main RAM, A=1 video RAM
	  LDA #108
	JSR OSBYTE      \ Attempt to select Master video RAM
	  PLA
	INX
	BNE vramOk       \ X<>255, successful
	  EOR #1
	TAX               \ A=1 main RAM, A=0 video RAM
	  LDA #111
	JSR OSBYTE      \ Attempt to select Aries/Watford RAM
	  .vramOk
	  PLA
	TAY
	RTS
	OPT FNendif

\ Tube communication routines
\ ===========================
	OPT FNif(SWROM%)
	  .TubeDelay               \ Delay for 24us
	  JSR TubeDelay2
	JSR TubeDelay2
	JSR TubeDelay2
	  .TubeDelay2
	RTS
	  .TubeEnterCode
	  LDA #4                   \ 4=EnterCode
	  .TubeAction
	  PHA
	  .TubeClaim
	  LDA #&C0+6
	JSR &406      \ Claim with ID=6 (HostFS)
	  BCC TubeClaim
	  LDX #TRANS AND 255       \ Point to transfer address
	  LDY #TRANS DIV 256
	  PLA
	JMP &406             \ Start transfer action
	  .TubeRelChk
	  BIT &27A
	BMI *+3
	RTS    \ If no Tube, return
	  .TubeRelease
	  LDA #&80+6
	JMP &406      \ Release with ID=6 (HostFS)
	OPT FNendif

\ Enter Code pointed to by TRANS transfer address
\ ===============================================
\ Checks to see if code has a ROM header, and verifies it
\ if it has. CC=entered from RESET, CS=entered from OSCLI
.EnterCode
	OPT FNif(SWROM%)
	  LDA &27A
	BPL EnterCodeIO         \ No Tube present
	  LDY TRANS+3
	INY
	BNE TubeEnterCode\ ADDR<&FFxxxxxx
	OPT FNendif
.EnterCodeIO
	PHP
	LDY #&07
	LDA (TRANS),Y         \ Get copyright offset
	CLD
	CLC
	ADC TRANS+0
	STA FAULT+0
	LDA #0
	TAY
	ADC TRANS+1
	STA FAULT+1 \ &FD/E=>copyright message
\
\ Now check for &00,"(C)"
	LDY #&00
	LDX #3
.EnterCheck
	LDA (FAULT),Y
	CMP CheckCopy,X
	BNE LF8FA
	INY
	DEX
	BPL EnterCheck             \ Check for &00,"(C)"
\
\ &00,"(C)" exists, check ROM type byte
\ -------------------------------------
	LDY #&06
	LDA (TRANS),Y             \ Get ROM type
	AND #&4F
	CMP #&40
	BCC NotLanguage  \ b6=0, not a language
	AND #&0D
	BNE Not6502Code           \ type<>0 and <>2, not 6502 code
.LF8FA
	TXA
	ROL A
	ROL A
	AND #1             \ A=0 - raw, A=1 - header
	LDX TRANS+0
	LDY TRANS+1
	BPL LF904  \ Entered code<&8000, don't move memtop
	STX MEMTOP+0
	STY MEMTOP+1          \ Set memtop to current program
	STX PROG+0
	STY PROG+1              \ Set current program to address entered
.LF904
	PLP
	JMP (TRANS)                    \ Enter code with A=raw/code, Cy=RESET/OSCLI flag
.CheckCopy
	EQUS ")C("
	EQUB 0
\
\ Any existing error handler will probably have been overwritten
\ So, set up new error handler before generating an error
.NotLanguage
	OPT FNif(SWROM%=0)
	  JSR InitError
	OPT FNendif
	M_ERROR
	EQUB 249
	EQUS "This is not a language"
	EQUB 0

.Not6502Code
	OPT FNif(SWROM%=0)
	  JSR InitError
	OPT FNendif
	M_ERROR
	EQUB 249
	EQUS "This is not 6502 code"
	EQUB 0


\ Low level I/O routines
\ ======================
\ This is where detailed playful frobbing is done to ensure a clean
\ error-free reliable link channel. All calling code assumes these
\ routines are 100% error-free and reliable. Any handshaking, retries,
\ error correction, etc must be done at this level.

\ Send a raw byte of data
\ -----------------------
\ On entry, A=byte to send
\ On exit,  A,X,Y preserved, P corrupted
\
.SendData
	PHA
.SendWait
	LDA TxStatus               \ Get Status
	AND #TxRDY
	BEQ SendWait    \ Wait until data can be sent
	PLA
	STA TxData
	RTS         \ Send data

IF CHECK_RTS
.TestRTS
	LDA TxStatus
	AND #TxRDY
	RTS
ENDIF
\ Read raw data
\ -------------
\ On exit, P =CC, no data
\            =CS, data present, EQ=esc, NE=not esc
\
.ReadData
	PHP
	SEI
	TYA
	PHA            \ Speed up by disabling IRQs
	LDY #RxCont
	STY RxStatus   \ Lower RTS to allow input
	LDY #RxStop
	LDA RxStatus   \ Get RxStatus
	AND #RxRDY
	BNE ReadDataOk  \ Data present
	PLA
	STY RxStatus
	TAY
	PLP   \ Raise RTS, restore Y,P
	CLC
	RTS                    \ CC=No data present
.ReadDataOk
	PLA
	STY RxStatus
	TAY
	PLP   \ Raise RTS, restore Y,P
	LDA RxData
	CMP #esc
	SEC
	RTS\ CS=Data present, EQ/NE=esc


	]
	IF(P%>IOSPACE%)AND(SWROM%=0)
	ERROR 1,"Code overrun"
	[OPT P*3+4
\ Spare space
\ ===========
	OPT FNif(SWROM%=0)
	EQUS STRING$((IOSPACE%-P%)AND255,CHR$255)
	OPT FNendif

\ I/O Space
\ =========
	EQUS STRING$(8,CHR$0)

\ Tube I/O Registers
\ ==================
.TubeS1 \ &FEF8
	EQUB 0
.TubeR1 \ &FEF9
	EQUB 0
.TubeS2 \ &FEFA
	EQUB 0
.TubeR2 \ &FEFB
	EQUB 0
.TubeS3 \ &FEFC
	EQUB 0
.TubeR3 \ &FEFD
	EQUB 0
.TubeS4 \ &FEFE
	EQUB 0
.TubeR4 \ &FEFF
	EQUB 0


\ DEFAULT VECTOR TABLE
\ ====================
.LFF00
	EQUW NullReturn      \ &200 - USERV
	EQUW ErrorHandler    \ &202 - BRKV
	EQUW IRQ1Handler     \ &204 - IRQ1V
	EQUW IRQ2Handler     \ &206 - IRQ2V
	EQUW MyosCLI           \ &208 - CLIV
	EQUW MyosBYTE          \ &20A - BYTEV
	EQUW MyosWORD          \ &20C - WORDV
	EQUW MyosWRCH          \ &20E - WRCHV
	EQUW MyosRDCH          \ &210 - RDCHV
	EQUW MyosFILE          \ &212 - FILEV
	EQUW MyosARGS          \ &214 - ARGSV
	EQUW MyosBGET          \ &216 - BGetV
	EQUW MyosBPUT          \ &218 - BPutV
	EQUW MyosGBPB          \ &21A - GBPBV
	EQUW MyosFIND          \ &21C - FINDV
	EQUW NullReturn      \ &21E - FSCV
	EQUW NullReturn      \ &220 - EVNTV
	EQUW NullReturn      \ &222 - UPTV
	EQUW NullReturn      \ &224 - NETV
	EQUW NullReturn      \ &226 - VduV
	EQUW NullReturn      \ &228 - KEYV
	EQUW NullReturn      \ &22A - INSV
	EQUW NullReturn      \ &22C - RemV
	EQUW NullReturn      \ &22E - CNPV
	EQUW NullReturn      \ &230 - IND1V
	EQUW NullReturn      \ &232 - IND2V
	EQUW NullReturn      \ &234 - IND3V

\ Print hex numbers
\ =================
.PrHexXY
	TYA
	JSR PrHex
	TXA
.PrHex
	PHA
	LSR A
	LSR A
	LSR A
	LSR A
	JSR PrNybble
	PLA
.PrNybble
	AND #15
	CMP #10
	BCC PrDigit
	ADC #6
.PrDigit
	ADC #'0'
	JMP ummOSWRCH

\ Print embedded string
\ =====================
\ Mustn't use LPTR so can be called from OSCLI
.PrText
	PLA
	STA TEXT+0
	PLA
	STA TEXT+1 \ CTRL=>embedded string
	JSR PrString2
	JMP (TEXT)      \ Print string and jump back to code

.PrString
	STX TEXT+0
	STY TEXT+1      \ CTRL=>string at YX
.PrStringLp
	LDY #&00
	LDA (TEXT),Y      \ Get character
	BEQ PrString2
	JSR ummOSASCI   \ Print character if not &00
.PrString2
	INC TEXT+0
	BNE LFEA6
	INC TEXT+1 \ Increment address
.LFEA6
	TYA
	BNE PrStringLp         \ Loop back if not &00
.NullReturn
	RTS


\ Standard Tube entry points
\ ==========================
\ NB! All API entry points must be called in BINARY mode
\
	OPT FNif(SWROM%=0)
	EQUS STRING$((&FF95-P%)AND255,CHR$255)
	OPT FNendif
.LFF95
	JMP NullReturn       \ &FF95
.LFF98
	JMP NullReturn       \ &FF98
.PRSTRNG
	JMP PrString         \ &FFC5  Print zero-terminated text at YX, returns A=0, Y corrupted
.LFF9E
	JMP NullReturn       \ &FF9E
.SCANHEX
	JMP ScanHex          \ &FFA1  Scan hex string at (&F8), returned in &F0/1
.DISKACC
	JMP NullReturn       \ &FFA4
.OSQUIT
	JMP ummCLICOM           \ &FFA7  Quit current program
.PRHEX
	JMP PrHex            \ &FFAA  Print A in hex, A corrupted
.PR2HEX
	JMP PrHexXY          \ &FFAD  Print YX in hex, A corrupted
.USERINT
	JMP NullReturn       \ &FFB0
.PRTEXT
	JMP PrText           \ &FFB3  Print zero-terminated inline text, returns A=0, Y corrupted
.ummVECDEF
	EQUB &36
	EQUW LFF00  \ &FFB6
.ummCLICOM
	JMP CmdPrompt        \ &FFB9  Enter supervisor *command prompt
.ummERRJMP
	JMP NullReturn       \ &FFBC
.INITERR
	JMP InitError        \ &FFBF  Initialise MOS error handler, A corrupted
.DISKRST
	JMP NullReturn       \ &FFC2
.LFFC5
	JMP NullReturn       \ &FFC5
.ummNVRDCH
	JMP osRDCH           \ &FFC8
.ummNVWRCH
	JMP MyosWRCH           \ &FFCB

.ummOSFIND
	JMP (FINDV)          \ &FFCE
.ummOSGBPB
	JMP (GBPBV)          \ &FFD1
.ummOSBPUT
	JMP (BPutV)          \ &FFD4
.ummOSBGET
	JMP (BGetV)          \ &FFD7
.ummOSARGS
	JMP (ARGSV)          \ &FFDA
.ummOSFILE
	JMP (FILEV)          \ &FFDD

.ummOSRDCH
	JMP (RDCHV)          \ &FFE0
.ummOSASCI
	CMP #&0D
	BNE ummOSWRCH  \ &FFE3
.ummOSNEWL
	LDA #&0A
	JSR ummOSWRCH  \ &FFE7
.ummOSWRCR
	LDA #&0D             \ &FFEC
.ummOSWRCH
	JMP (WRCHV)          \ &FFEE
.ummOSWORD
	JMP (WORDV)          \ &FFF1
.OSBYTE
	JMP (BYTEV)          \ &FFF4
.ummOS_CLI
	JMP (CLIV)           \ &FFF7

.ummNMIV
	EQUW NMIHandler      \ &FFFA  NMI Vector
.ummRESETV
	EQUW RESET           \ &FFFC  RESET Vector
.ummIRQV
	EQUW IRQHandler      \ &FFFE  IRQ Vector
	]
	ENDPROC



	]
	IF (opt%AND3)
	IF (Serv3Boot AND 255)>&F4
	P."WARNING
	Serv3Boot overlaps"
	ENDPROC